# 如何在struct里追加指针

这在其它公司或开源项目没有什么用，但至少在我目前的工作上还是有一定价值的。想象一下不同的部门共用同一份头文件，头文件中复杂的类型只能用结构体。如果要在结构体增加任何元素，都要保证结构体长度不变。对char或是int32问题不大，指针在不同平台长度是不一样的，如果一个部门用32位编译，增加指针，试问要怎么减长度才能保证在64位平台长度不变？曾经考虑过32位平台加宏，在指针后面带一个int32并用宏控制，但是想找到各种平台都能识别的宏很困难。

先说思路，既然要保证32位和64位相等，肯定是向上取长度，即让指针占据8字节，有三种做法：

1. 把指针和int64用union包裹起来放到结构体里，如下
<pre>
    struct {
        int elem1;
        int elem2;
        union {
            char* p;
            int64_t placeholder;
        }u;
    };
</pre>

这样做不好的地方在于取指针p必须要多一重u，使用者会感觉不方便。

2. 既然用union看起来别扭用着也不方便，让struct强制以8字节对齐，然后把指针放在8字节位置，同时指针后面的元素必须是int64/double，这样32位系统下，指针后面会有4字节的隐藏字节，但也不能用，64位就是按8字节对齐的。缺点是指针后面的元素必须是8字节，有时会很浪费。如下
<pre>
    struct {
        int elem1;
        int elem2;
        char* p;      /// 32位系统，p后面有4字节空间，但不要使用
        int64_t ensureAlignBy8;
    };
</pre>

3. 定义一个占位宏，根据系统特性将宏展开成int32_t或是空语句，也是最终我决定采用的方式，宏类似这样
<pre>
#ifdef (_WIN64)
#define POINTER_ALIGN8(n)
#elif (_WIN32)
#define POINTER_ALIGN8(n) int32_t unused##n;
</pre>

这里有个小坑，宏的展开必须包含`;`，我最初的实现是宏的调用尾部加分号，过了几个月有人向我反馈编译不过。原因是VC在编译C语言模式(即.c后缀)时，要求结构体的定义中不能出现一行单独的`;`，但是在执行块中可以这么用。VC编译`C++`模式或GCC都没有这个限制。当我遇到这个错误时，曾尝试通过将64位下的宏扩展为一个空结构体，VC会报C标准不允许结构体没有成员。