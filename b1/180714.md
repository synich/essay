Lisp的宏
====
都说Lisp的宏很强大，其最大的特征仍然是字符串展开和替换，只是在替换的过程中，可以结合环境进行适合的绑定，加之程序和数据的同构，才使它异常强大。本文以s7的传统宏实现来理解宏。

我最初最大的困惑，在一个宏定义的开始，要不要加\`？以一个最简单的宏来做实验。

```
1. (define-macro (print arg) (display arg))
2. (define-macro (print arg) `(display ,arg))
3. (define-macro (print arg) `(display arg))
```

* 情况1，不加\`。在宏展开后，就进行运算，并得到最终结果。展开的结果类型是表达式的返回值。没有\`也就不能用\,，参数无法求值，即使是未绑定的值，只是作为一个symbol来用，未绑定的值并不会报错。比如(print ar)会输出ar，甚至ar有定义时，也只是输出ar。这种宏展开，只是最单纯的展开，没有求值替换，和C的宏能力等价。

* 情况2，加\`。宏展开的类型就固定是pair，仅仅宏展开并不求得最终值。只有把宏展开的结果，再用于eval才能得到宏最终的结果。宏变量也会成为宏展开时环境的一部分，再传入无意义的变量会报错。

* 情况3，加\`但忘记用,求值。宏展开期间参数没有用，eval时只能从当时的全局环境找绑定，不确定性很大，有点类似动态作用域的效果，不建议用。

所以调用宏，相当于展开宏并把展开结果绑定到一个匿名变量，展开前会把参数作为新的frame插入环境中，如果出现求值，再用eval对这个匿名绑定求值两个步骤。有时看起来加\`和不加效果相同，是因为不加\`相当于宏展开后已经是个self evaluating值，再做eval看不出变化罢了。要注意：加了\`但没有把参数用,进行求值，则这个参数就会在eval阶段引用全局的同名参数。

由于scheme是strict语言，只要遇到表达式就求值(但set!的第一个参数和宏的参数在宏展开前是不求值的)。