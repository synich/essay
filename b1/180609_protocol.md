论RESTFul特性
====
产生RESTFul的领域，似乎不能涵盖API风格。要求URL以名词性单词结尾，典型的比如心跳，要作为什么样的资源呢？也许可以强作令牌，但其它需求未必有适合的名词。

再提一点很现实的问题，浏览器的GET不能携带body。RFC7231说明payload是no semantic的，XMLHttpRequest的实现会不允许发出，PUT/POST/DELETE可以。这就导致复杂的查询请求只能用POST来实现，已然破坏了获取语义。

再说点XHR作为本地页面，会把PUT和DELETE作为OPTION发出，内容不变，这就涉及到浏览器跨域场景中额外加入的preflight特性，POST如果Content Type改了也会遇到，GET似乎不会。

转载一个观点，带来几个问题：

数据定制的问题：我们的应用数据现在越来越丰富，已经不是10年前可以相比的了，也就是说数据的返回可能很丰富，非常大，而我这次可能只要其中一小部分，比如说我请求一个用户的数据/user/1，我只要他的名字和头像，而并不需要他几千个好友。传统的Rest，你可以加个Mask参数，例如/user/1?friend=false 这种方式无疑增大了前后端的代码复杂度，增加了开发的强度，而且也不够灵活，难道我要给每个字段都加个Mask？后端要依赖各种可能的Mask组合来生成查询也是个麻烦事儿，这种代码写出来也是难维护。

多次请求的问题：类似上面提到的灵活性问题，上面说我们要少要点数据，那我们这次想多要些数据。比如说我想要一个用户的所有好友，还没完，再加上每一个好友的所有好友。这在传统Rest里面，往往我们就使用多次的请求，拿到1度好友的列表，然后写个循环，依次拿到所有2度好友。这当然不够优化，于是可能你会再设计一个专门的API去一次性拿到所有2度好友。同样的问题，这增大了前后端的代码复杂度，不够灵活，万一下次我要3度好友呢？

异常处理的问题：这个很多朋友都会有自己的办法，有些朋友会返回特定的http response code: 4XX, 5XX，有些朋友可能会返回特定的Json消息。比如说/get/user/8527, 如果这个用户不存在，你可以返回404，你也可以返回自定义消息｛msg：“user not found”｝。这很多时候也不是问题，但我觉得如果使用更结构化的异常处理方式，应该会好些。

发出一个请求，我不知道会得到啥：结合上面几点，其实你会发现，如果你请求一个资源，例如/user/1，你并不知道结果里具体会有什么，你可能需要查阅文档，但文档可能已经过期。你可以自己实验，但你不知道是否覆盖了全部可能的情况。这是一个很痛苦的过程。
PUT和DELETE也是个坑：这需要前后端框架的支持，如果不支持怎么办？其实我也不知道，我这么多年一直尽量避免使用PUT和DELETE来设计API。

每个resource都有自己的一组end point或者说URL，这会带来管理和维护的麻烦。
安全问题：Rest难以避免的从URL上接受各种参数（parameter），不严格的使用Get等都会造成安全的隐患。有些问题GraphQL上也有，而且我不是这方面的专家，就不细说了。