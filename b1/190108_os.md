# 环境变量的继承

操作系统有一片空间保存环境变量，我猜测这只是一片只读空间，每次用户登陆会创建一个会话，这个会话首先继承了全局的全局变量，如果脚本中export了某些环境变量，会作用到这个环境，但是其它用户登陆后，完全不受影响。

典型的同一个账号，先export A=123，另一个会话也指定export A=456，不会影响前一个会话，这是两个完全隔离的会话。export的效力仅及于该此登陆操作。

再看看同一个会话中启动一个shell进程会如何。每个shell创建的进程，除了argc, argv 就是env了，父子间的env到底能不能打通呢？事实表示，父改了，子会受影响；但子改了，父是感知不到的。

如果不考虑fork子进程，仅仅当前环境使用的话，不需要export，仅使用 A=123 就会在当前环境创建变量，只是子进程无法看到这个变量罢了。

综上export不是定义环境变量必须的语法，只是为了让子shell能感知到，将环境变量**提升**到可被子shell感知到的区域。

说了shell顺便说说tty和terminal这两个概念。远古时代的计算机需要穿孔打印机和纸带进行操作，自从有了电传打字机，打字机输入，输出会打到纸上，虽然有些费纸，但已经比纸带有了巨大的进步。大型机体积巨大，但多人需要使用，所以每个人看到的就是terminal，tty算是最原始的终端形态。

打印到纸上也勉强能算，毕竟不方便，随着70年代末出现的CRT显示器，terminal更多地被用于video terminal的简写。至于现在的软tty，包括各种stdin, stdout只是保留这个概念，形式上已经差别很大了。