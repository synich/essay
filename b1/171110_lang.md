比较词法分析和语法分析
====
词法分析是一种单向的状态机。最简单的词法分析，只要不停的吞入字符并和状态表中的可选项进行匹配，并把匹配上的字符挑选出来就可以了。稍微复杂一点的则可以加入把匹配项里面的部分字符退回，但这个状态更多的像是一种人为的操纵，而不影响状态机的本质。另外在比较的时候有一个很简单的判断，就是称之为最长判断，但这种判断也不会造成过多的选择负担。

由于输入的数据始终只有一种状态，所以不需要保存过去的数据，当然也不存在栈溢出问题。

语法分析相比起来就要复杂很多，是一个带有栈的，且栈深度是可伸长的状态机。因为一个不带栈的语法分析器，比如LR(0)，能够分析的语法是非常少的。要想达到可用，至少要保存向前看的一个数据。另外归约时要根据向前看的数据进行选择，也要把一段时间内未归约的数据保存下来，这就需要栈，当归约的语法太复杂，或者歧义太多，保存在栈上的数据过多，就可能导致栈溢出的问题。

从我查到的文献看，1965年的ACM就刊载了TMG compiler compiler语法分析文章，这个工具在70年代初移植到了最早版本的unix，但在用TMG给B语言扩展特性时却很困难，因此才基于LR解析理论重写了yacc（yet another就是针对TMG而言），并随着version 3 unix一起发布。而lex虽然更简单，但资源很少，只查到1975年lex论文发布（同年yacc论文也发表了）。由于年代久远，二者都是不可重入的。随着线程的出现就出现了可重入的需求，lex可以使用%option reentrant生成可重入代码，如果比较会发现和非重入版的代码差异极大，yacc也能生成可重入代码，而更新的语法生成工具如lemon，生成的都是可重入代码。