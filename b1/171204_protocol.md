修改能力协议的思考
====
对一个视频通道获取智能能力的协议，原来的协议只有一条能力，这种描述不足在于能力有当前能力和潜在能力，嵌入式设备的能力不是孤立的，会受制于其它资源，因此协议上要有两个能力。如果只到这里为止，协议就结束了，但接下来的实现就相当地狗血。

因为用了RPC方式，每个协议和接口对接，接口中只定义了一个caps参数，无法把协议的full节点映射到头文件。通常这种时候再增加一个接口，用来获取full能力，并在RPCServer中调用两次把能力返回也是可行的。此时第二个坑出现了，所有的接口定义在类当中，而类的接口数量是有上限的！此时这个类的32个接口都用完了。当然这种情况也遇到过，换一个类增加接口就是了。但偏偏这个类不是管理类，协议调用这个方法是通过工厂方法的instance，并传递通道号来获取类实例指针方式，比如当前的智能类名字是DevVideoAnalyse，客户端会先指定通道2获取对应的实例token，接下来通过token去访问getCaps方法，到了getCaps的实现只有token，无法映射到DevVideoAnalyse2这个实例(因为无法直接得到通道号)！变通的作法是建立token和两个类实例的绑定关系，这样一来又要多费很多周折，且为这一个方法也没有必要。

最后的解决办法是在getCaps的请求中增加一个channel，通过channel重新获取DevVideoAnalyse2的类实例并调用方法获取full能力。当然这样做协议就显得很冗余，也是协议被实现绑架的一个例子。

我一直对先获取资源指针并操作这种模式很反感，协议不应该暴露资源，如果不是这种模式，虽然类有32个接口数量限制，实现上并不会很丑陋。