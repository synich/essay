# 给应届生出题看指针的易错点

上周领到给18届毕业生出题目，我被分到OS方面的基本题和两道编程题，基本题不能简单考能查到的题目，最后出了几个Linux偏操作的题目。两道编程题中有一题，在自己实现时遇到了两个指针方面易错点。

题目是这样：N个人排队，每个人都有个编号（数字），要求排序后让这些编号连在一起之后组成的那个整数最小
比如 14  78  132  56  8，排列后的顺序是132 14 56 78 8。这道题目难点并不在排序算法，主要是看能不能读懂排序比较函数，比较两个字符串，首字母小的认为小，如果前N个字母一样，先结束的认为小。

我在提供标准答案时，直接用C语言的qsort函数，原型是这样 `void qsort( void *buf, size_t num, size_t size, int (*compare)(const void *, const void *) );`

第一个参数显然要对数组排序，因此排序`*`后，void就要换成元素的真实类型，比如这道题目是`char*`，第二、三元素很好理解，重点在第四个函数指针的原型，刚才已经分析过，真实元素类型是void，对比函数原型是`void*`，说明函数参数要多一重指针，即`char*`传到比较函数时时`char**`，这个开始没发觉，反复调试并才意识到错误。

再就是比较函数，这道题是比单个字符，如果两个字符串是`char *p1, *p2`，开始我用了`p1-p2`，并误以为是字符串首字母比较，其实从类型看到，相减的是`char*`即指针地址，这样比较结果不会影响数组排序，原因就是比较指针地址当然不可能影响排序，所以比较要用`*p1-*p2`才能得到想要的结果。