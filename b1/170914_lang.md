为什么C语言的long类型长度不确定
====
C语言的规范没有规定long必须是多长，只要求不小于int就可以。从我看到的情况int都是4字节，但long就有32/64两种长度。典型的像VC把long当成32字节，而Linux的GCC则把long当成64字节。

造成这个差异的根本原因其实并不是编译器，因为今天意外地发现GCC在windows平台上是把long当成32字节，说明long长度不仅仅和编译器相关，那么为什么windows的long会是32字节呢？

恰好昨天提交一个头文件，修改结构体定义BITMAPINFOHEADER中四个long类型为uint32，我查了下BITMAP的要求，明确说MUST BE 40bytes。但是这个结构体有10个字段，6个INT和4个LONG，而这个定义又是抄自windows.h的定义，说明当时在微软定义头文件的这个哥们就是把LONG当成UINT来用。没有看过所有头文件，也许那时所有人都认为32位已经足够用了。然而时至今日出现了64位，如果这时把LONG定义成64位，BITMAP头文件就不能和真实的文件匹配上了，必须让LONG保留32位，而且不仅微软自家编译器，是所有跑在windows平台的编译器都必须按32位来对待long。在Linux平台没有和文件格式强绑定的头文件定义，因此GCC就把long当成64位来处理了。

由此可见头文件的定义，一旦落了地影响就无比深远，远到当初定下这个结构的人，都不曾预料到会演变成今天的情景。