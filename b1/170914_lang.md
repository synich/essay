# C语言的类型长度

## long类型该多长

C语言的规范没有规定long必须是多长，只要求不小于int就可以。从我看到的情况int都是4字节，但long就有32/64两种长度。典型的像VC把long当成32字节，而Linux的GCC则把long当成64字节。

造成这个差异的根本原因其实并不是编译器，因为今天意外地发现GCC在windows平台上是把long当成32字节，说明long长度不仅仅和编译器相关，那么为什么windows的long会是32字节呢？

恰好昨天提交一个头文件，修改结构体定义BITMAPINFOHEADER中四个long类型为uint32，我查了下BITMAP的要求，明确说MUST BE 40bytes。但是这个结构体有10个字段，6个INT和4个LONG，而这个定义又是抄自windows.h的定义，说明当时在微软定义头文件的这个哥们就是把LONG当成UINT来用。没有看过所有头文件，也许那时所有人都认为32位已经足够用了。然而时至今日出现了64位，如果这时把LONG定义成64位，BITMAP头文件就不能和真实的文件匹配上了，必须让LONG保留32位，而且不仅微软自家编译器，是所有跑在windows平台的编译器都必须按32位来对待long。在Linux平台没有和文件格式强绑定的头文件定义，因此GCC就把long当成64位来处理了。

由此可见头文件的定义，一旦落了地影响就无比深远，远到当初定下这个结构的人，都不曾预料到会演变成今天的情景。

## int类型该多长

历史上，不是所有计算机都是一个字节 8 个 bit 的。只是由于一系列优势 (比如刚好能容纳下 ASCII 码 + 1 位校验位)，所以 8 bit 的计算机成功吃鸡，成为了今天最常见的架构。

如果你仔细的话，会发现 C 语言标准头文件 <limits.h> 中规定了一个宏 CHAR_BIT，用以表示字节位数。这个宏就像历史文物一样向今天的我们诉说历史的沧桑。我们今天写代码时，如果要计算一个 int 有几位，三流程序员可能直接返回 32。但是大家都知道，直接返回 32 的代码，没有考虑到标准中并没有承诺 int 就是 4 个字节，所以兼容性是要大打折扣的。一般人会返回 sizeof(int) * 8，但是这同样有问题。正如上面所说，不是所有计算机都是一个字节 8 位。所以正解应当是 sizeof(int) * CHAR_BIT。尽管在今天，99.99% 的情况下 CHAR_BIT 被 define 为了 8，但在有些特殊领域，仍要考虑到非 8 位的特殊情况。

了解了这些，站在当年的角度思考这个问题，有些机器的硬件，是没法原生支持 int8_t, int16_t 等等的 (因为它们的整型位数就不是 8 的整数倍)。更别提就算是 8 的整数倍的 16 位的计算机都没法原生支持 int32_t, int64_t (超过它们的最大字节数了)。

PDP-10，后期命名为 DECSystem 10 的字长是 36 位，字节是 9 位，一个机器字内可以有许多种不同的打包（Packing）方式，这机器的一个 CHAR_BIT 就是 9。

对于 PDP-10 存储字符，还有其他的打包方式：

* 六个 DEC Radix-50 字符打包进 32 位中，剩下 4 位留空
* 六个 6 位的字符（DEC SixBit，ASCII 0x20——0x5F 这一段）
* 五个 7 位 ASCII，1 位留空
* 四个 9 位字符（Multics 约定）
