# Lisp文章读后感

RethinkDB作者的理解，从XML，C语言宏等角度作了比喻。

XML是一种数据表示，但Ant中可以表示行为。如果把尖括号和属性(只是为了少打字的节点的一种简写，非必须的特性)做变换，最终呈现的就是Lisp的多重括号。

用C宏和元编程做比较，日常有太多的boilerplate代码要写，宏是理所当然的选择，但如果能用host语言来无缝处理显然更好。

Henry G Baker的实现思路
----
把Scheme转成C用到CPS变换，常见的思路是trampline，但这种方式会慢2-3倍。提出了一种永远不return，不停地让栈生长，内存分配都实现在栈上，使栈堆合一简化分配。当栈达到极限，用Cheney的GC方法进行收集。

C语言禁止嵌套函数，目的就是阻止free变量的引用。只允许toplevel函数，free变量惟一的可能只有全局变量，编译器会维护一个环境指针，可以找到这些全局变量。Pascal允许嵌套定义函数，不清楚怎么解决。

自己的体会
----
symbol是为了区分函数求值和数值表示。最初存在Mexp和Sexp两种，最后以quote的形式把Mexp给去掉了。所以只能说数据和函数同构，但不是相同。在lisp体系中完整体现了外部表示->符号->值的两次转换，没有quote符号，不过是换一种语法的lua。

symbol不仅能表示简单的变量，也能表示list，因此具备树状结构，而string只是字符线性排列。换句话说，string能看起来无缝地表示成symbol，部分symbol变成string后就大不相同了。让我们混淆的是自表示symbol，比如数字1，当eval作用在结构的symbol上，求值就变得统一了。

写宏的时候，\`把sexp标识成数据，而`,`则起到了局部eval的效果。

反过来想，PHP/JSP这些语言的默认标识成数据，用了`<?`就把进行求值演算。只是PHP缺少数据和程序互操作的能力，而Lisp打通了两者的边界。

既然函数和字符串本质都是一段二进制值序列，只是类型不同，所以计算时对这个值的eval也不同。环境是若干个frame构成的list，闭包是带env的函数，而类不过是生成对象的函数模板（let over lambda）。所以说在静态作用域出现之后，闭包和对象的界限才被打破。

R5RS中，pair和vector是两种最基本的数据结构(procedure)。hash是一种高效的实现，但本质上可以用list实现。最简单的做法是单向链表，但是红黑树一样可以用list来表示，此时就不能以car来取值，而要针对树的list结构定义专门的函数，如果要用bucket方式，则会用到vector，元素是list。

continuation在1964年由Wijingaarden首次提出，有点ES6的Promise味道，到72年广为人知。Kamal Abdali在会议上发表论文，把Algol60转为untype lambda计算。提交第一届ACM符号被拒。他在74年完成他的毕设。他的推荐人提到，将语言转为"pure" lambda，比如赋值就modeled by substitution，而不是内存，地址，存取操作。

推演时，把k代表的符合消去，就能看出在current时间点，要做的是什么，再把参数找到，因此要做两次推导，所以显得复杂。
