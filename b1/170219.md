函数式和对象式，表达式和语句
====
伞哥在微博提到，ML的函数语法如果有多个参数，当参数没有完整传入时，并不是像Lua/PHP等一样赋值为nill，而是返回一个curry化的函数。这种思路如果移到协议处理上来，和组件化的实现是不同的拆分方式。

协议入口收集所有的参数，如果用curry化的思路，则每个步骤只处理一个参数，然后返回新的函数，并处理剩下的参数。如果第一个参数要做分派，则可能会返回两个不同的函数。通过这种方式，把过程拆分。

如果是对象化的拆分，则根据业务划分若干阶段，每个阶段对应一个类，这种方式不会严格限定参数个数，可能第一次就处理所有的参数。不过函数式其实也可以处理所有参数，返回的函数接收新的参数也无妨。不管怎么样都是一个拆分的过程。

函数式典型函数的理解
--
scala没有break和continue关键字，因为它并不鼓励中途退出或跳过机制，而应先待循环的数据进行过滤再完整处理。引申出对函数式几个最典型函数的思考。

* filter 传入函数 x => bool，只保留返回true的内容，达到缩减原始数据的效果
* map 传入函数 x => z，返回一个新的，但长度不变的向量数据集
* reduce 传入函数 x, y => z，返回一个“标量值”。之所以打引号，是形式上返回的结果可能不是一个简单的数字，但维度上，和原始向量数据的任一项是相同的

如果要取向量的前3项怎么办？这时可以在filter中传入闭包，用闭包的状态是否到3来控制返回true还是false，因此这三个构成函数式处理的完备集合。另外从这种处理方式可以看出，只要顺序迭代器就能满足计算，并不需要随机迭代器，但从处理的便利性和效率上来说，随机迭代器有其不可替代的优势。

对一个数据集做groupBy操作的结果，就是典型的顺序迭代器，一方面不知道总长度，更重要的是内部数据的无序性，导致随机访问没有意义。

表达式和语句
--
在PL界，不管平时有没有注意，大都会区分expression和statement。expression的定义是计算并返回值，而statement表示操作，对返回值没有要求，甚至干脆禁止。看似都有计算过程，无非是对返回值的区别，但细想下去，如果没有返回值，就只能靠全局变量来通信，显然是不行的。对函数式编程而言，expression是强要求。

JS细分了语句和批语句，批语句必须有{}，典型如switch,try,catch,finally。而像if,for,while都可以省略。Lua严谨，只有批语句的概念。

最直观体现两者区别的就是*赋值*。lua或python的赋值是statement，没有返回值，因此print(a=1)会报语法非法。而C、JS则把赋值后的左值返回，python3.8也加入了:=，使赋值成为表达式。还有scheme的set!实现了赋值，但返回是未定义值，可以打印但无意义。

Lua的函数返回0到多个值，而JS的函数只能且一定会返回一个值。返回多值的函数如Lua和Go，一种惯用法是返回值第一个为bool表示成功或失败，剩下的是实际需要的返回值。而JS和PHP都只能返回单值，加上JS的函数签名不支持显式引用，如果JS要从函数出参取值，只有使用对象才可以。