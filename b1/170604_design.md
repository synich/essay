从串口功能的封装看如何抽象
====
串口并不是不可分割的一体，就好像网络socket的TCP和UDP是差异巨大的两个类别，232和485的差别也是非常之大。之所以会混为一谈，只是对它了解不够，所以必须区别对待。

232串口有点类似TCP，类似虚电路的点到点连接，且一个串口只能连接一个设备。而485串口则类似UDP，一条总线挂载多台设备，以类似广播方式发送消息。从硬件层面(PAL)抽象无非就是把一个串口作为一个对象，把设置串口属性、读、写都作为独立接口，这无可厚非，但应用层如果也只是简单封装，232可能没问题，485则会有严重不足。

设想485上挂的两台设备使用的波特率、奇偶位都不相同，但又因为硬件限制要共用一个硬件，每次发送消息前都要先设置串口属性再发送，如果是等待结果的消息，还必须等待读返回。三步操作如果任何一个被其它线程从中切入都会造成数据异常。因此485串口属性设置和读写必须是原子化的，应用层的操作接口要基于硬件层原始接口封装,而且PAL要提供锁接口才能保证不同上层使用同一把锁。

综上，485串口比较理想的抽象应该是PAL层提供原子化的设置/读/写接口，并提供接口间的锁。应用层基于这些基础设施，提供更高一级的设置写读一体化接口，才能满足一个串口接不同设备的通信需求。