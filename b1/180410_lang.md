JS和AWK语言的new和delete
====
new
--
在JavaScript中，使用new关键字后，意味着做了如下四件事情：

1. 创建一个新的对象，这个对象的类型是object；
2. 设置这个新的对象的内部、可访问性和[[prototype]]属性为构造函数（指prototype.construtor所指向的构造函数）中设置的；
3. 执行构造函数，当this关键字被提及的时候，使用新创建的对象的属性；
4. 返回新创建的对象（除非构造方法中返回的是‘无原型’）。
在创建新对象成功之后，如果调用一个新对象没有的属性的时候，JavaScript会延原型链向止逐层查找对应的内容。这类似于传统的‘类继承’。

注意：在第二点中所说的有关[[prototype]]属性，只有在一个对象被创建的时候起作用，比如使用new关键字、使用Object.create、基于字面意义的（函数默认为Function.prototype，数字默认为Number.prototype等）。它只能被Object.getPrototypeOf(someObject)所读取。没有其他任何方式来设置或读取这个值。

Lua也是基于原型的语言，虽然它并没有自带new关键字，但可以从第三方库看到模拟。比如loop库的实现，就执行了`setmetatable(object or {}, class)`，使用一个现有或创建新对象，并将这个对象的元表指向另一个表，关键特性和JS一样。

由此可以看明显看出和基于原型和基于类的构造差异。比如C\+\+的new，第一步类似，开辟一段新的空间存放对象，不可能有第二步设置原型指向动作，直接把这块新的空间作为this指针执行构造函数，最后返回对象相同。

delete
--
带有垃圾回收的语言，很大的好处分配对象不需要手动考虑回收的问题。但JS和AWK的关联数组对象，允许用delete语法手动删除某个指定元素，GNU的AWK扩展还允许用delete obj;这种语法把obj内的所有key value对一次性全部删除。

须知GC的运作要依赖对象的可达性或计数值，但不论是哪种，关联数组内的成员的生命周期都受外层变量的控制，无法单独的让GC去释放。类似的问题还出现在函数的upvalue上，只是因为upvalue是匿名的，而且和函数模拟的对象有密不可分的关系，因此只针对关联数组提供了delete语法。

之所以会想到这个问题，是因为lua5.4的work1版有个很大争议的改动：table中nil到底是什么语义。到5.3版本为止nil是相当于delete语法的作用，但这就产生了另一个不一致，nil作为基本类型却无法放入table中。这种不一致让语言的作者觉得是个必须要解决的问题。

比较两种语言的使用方式，这大概就是delete存在的意义吧。

附：AWK语言
--
在shell中诸多工具中，AWK是相对功能最丰富的工具，只有它可以创建函数。整体代码结构由复数个awk rule和可选的函数定义组成，每个rule由pattern和action两部分构成。pattern可以省略，默认捕获整行，action就是要做的动作。最常用的pattern是匹配一行中某部分的内容；另外有两个特殊的pattern，分别是BEGIN和END。如果只有BEGIN块，甚至不需要读文件，此时相当于执行脚本。

整个脚本会编译两次，先找出函数定义，再编译awk rule（和JS有点类似）。所以函数块可以放在任何位置，为了不遮挡主体逻辑，建议把函数块放最后。

体例如下
```
pattern {
   action
}
function xxx() {
}

pattern := BEGIN | END | /regex/
```