# Openresty代码初读

我在公司内网的服务器从Apache httpd换成Openresty也有半年左右了，切换之后没有去深入研究，最近重新开始研究，一点初步的理解，记录在这里。

nginx给我最初的印象不是快或者节省资源，而是它居然的扩展机制。现在的软件都说自己是插件化体系，放个dll或so进去就可以增加功能，但nginx却需要每次重新编译，把扩展代码和执行程序编在一起才行。好像淘宝有个Tengine的扩展，可以用动态库的方式扩展，不过openresty没有用，那就还是看nginx的代码好了。

openresty的编译也是用configure脚本，却不是用GNU的auto系，而是在平级目录下有个auto目录，里面有各式各样的脚本检测OS或编译器选项，这块不清楚是不是个独立的项目，又或者是作者自己手工写的。

nginx编译添加模块的方式是在./configure后面用--add-module=指定路径方式，从configure脚本可以看到，是在指定目录下寻找config文件，如果有再从config文件读入相应的源代码和模块名信息。config定法也不复杂，就定义一些shell变量，然后统一被写入编译文件列表。nginx内一个很重要的概念是模块，代码中是个名为ngx_module_t的结构体，官方提供的http和mail功能是用模块，扩展功能也是同样实现这个模块。在core目录下，可以找到`extern ngx_module_t  *ngx_modules[];`这样一句声明，而在main函数中就直接循环遍历这个数组了。找遍nginx目录也没有找到这个变量定义的地方，再结合每次扩展需要重新编译，恍然大悟去编译目录objs/下果然找到`ngx_modules.c`这个文件，里面赫然定义了`ngx_module_t *ngx_modules[] = {`以及之后的若干个模块，之就是nginx静态编译扩展的原理了。模块分了CORE、CONF、HTTP和MAIL四个大类但定义是分散在core/http/mail三个目录下，似乎除了CORE会用于逻辑判断，其它几个并没有严格地规定。模块版本号目前都是1，也没有做逻辑判断，可能是为了将来扩展吧。另外模块中真正起作用的，就是content指针和7个函数指针。不过有些扩展模块并未实现函数指针，只有content是必须实现。或许是因为大多数模块并不需要参与nginx的核心调度，只要有content环境能和核心进行交互即可。像openresty中非常重要的lua扩展，也只不过实现了7个函数指针中的`init_process`这一个函数。

由于模块是编译进程序，运行自然也就和nginx在同一个地址空间，遍观如今排名前20的主流语言，体积小功能完整的，还真就只有lua了。因为扩展是直接在nginx的worker进程跑，如果扩展出点问题，worker进程是会直接挂掉的，开始我不知道，用ngx.say去遍历打印ngx内部的成员名和类型，结果浏览器就没有结果显示，后来看了代码才发现，因为table中有ngx.say不支持的类型值，结果lua扩展直接触发了abort();这个问题后续还是要注意，如果nginx中要执行长会话动作，这种abort还是很危险的。