词法语法之后
====
以前写过3篇词法语法工具使用的记录，对完整的编译过程来说，后面的代码生成和执行却一直忽略了。

如果只是写计算器，到语法生成勉强还够用。但要想支持分支，函数定义、调用等，
复杂性就真正体现出来了。

为了引入函数，必须把解析分为定义态和执行态。从函数定义开始到结束，要做代码生成。其它情况则取指令执行，是两个完全不同的处理，可以加标志位控制，也可以决定是否允许嵌套函数定义，简单起见可以先禁止。

要保存函数定义，就要有一套指令码和虚拟机来执行。指令可以不必多，但基本的Load/Save/Cmp/Jmp/Call是不可少的。从Load/Save又可以分为基于栈和基于寄存器两大流派。

构建指令集，先确定用定长或变长，基于栈还是寄存器。以定长寄存器为例：将若干bit位解码为指令，指令一旦确定，剩下bit位的操作数的解析方式就随之确定了。不同指令需要的数是不同的，1到3个都有可能，所以操作数的解析并不固定。使用拉掩码方式分别提取对应位数构成数据。

指令集除了表示做什么外，寄存器和立即数都是用索引号代替，所有的寄存器用栈形式分配，立即数要有常量池来存储和索引。如果不允许函数内嵌套定义函数，指令集+常量池这种模式就足以表示了。如果允许嵌套定义，要函数原型内递归地存储，难的是要处理upvalue。反观C语言，既不允许嵌套定义，最外层只能是main函数为入口，实现就相对简单而纯粹了。

有了指令集，还必须记住当前的指令执行位置，IP指针，在Lua中用savedpc变量保存。取指令用`*(savedpc++)`，执行当前指令时，IP指针已经向前走了一步。IP指针和函数在全局栈上的位置共同构成一个函数的必备元素。

指令通常顺序执行，加上比较和跳转后，就能实现分支和循环，跳转步数需要一些技巧获得。

指令，变量环境，常量环境，这3者构成函数原型的全部，运行时再将常量加载到变量。也可以将常量全部做成伪变量，只是写代码会非常繁琐。