版本管理工具的历程
====
到今天为止，版本管理工具可以粗略地分为三代：

1. SCCS在1972年开创了版本管理的理念，最初是用SNOBL4开发，后来借着Unix的东风，以C语言重写并跑在PDP-11上，这个软件现在已经没有维护了。第一代中还在维护的，是诞生于1982年的RCS，在GNU上能找到最新的发布版。
2. 中心式管理，代表为出现于1986年的CVS和2000年的SVN，其中SVN至今还有旺盛的生命力，在企业市场也非常有竞争力。
3. 分布式管理，为了适应互联网出现后的开发方式，2000年出现了BitKeeper(和SVN同年)，稍后的2005年4月，同时发布了广为人知的Git和Hg，仍在蓬勃发展。

第一代版本控制都是针对文件为单位，RCS使用的`,v`方式保存文件，被CVS继承。这一代并没有多人合作的概念，每次编辑文件前必须要先锁定，提交后再释放。在2010年前后，日系传统企业的软件管理，仍在使用。

第二代的CVS作为中心存储式版本管理，工作路径不放任何历史，虽然每级目录下都会有CVS目录，但里面的内容都是同样的3个文件(开分支会多个Tag)，Root和Repository共同构成了仓库的存储路径，Root文件保存远程档案的路径，如果是个网络地址，要求系统中必须有rsh，所以windows下无法看到远程的历史记录。Entries的内容则多一点，要记录该目录下被管理的每个文件名。

现在还在用cvs管理代码的项目里，我所知名气最大的是OpenBSD。它和cvs的渊源还有个故事：OpenBSD是开源的，但创始人Theo de Raddt觉得只开源代码而不开源代码历史是不够的，在1995年的秋天开放了anoncvs这个系统，并提出了open source repository概念，虽然现在可能有了更好的协作方式，但这在当时还是很有启发性的。

观察CVS的REPO目录可以发现，CVS和第一代都是以文件为最小单元进行管理的，与之对比svn是以目录为最小单元。理论上cvs的控制粒度更精细，相应的操作也更繁琐。cvs的所有命令，都可以不带文件名，表示当前所管理的文件都受此命令控制，达到了对目录整个操作的目的。比如svn固定版本只能对目录固定到某一版本，如果基于特殊原因，想对其中一个文件使用旧版本是做不到的，用cvs就可以在整个REPO指定版本的基础上，再附加对某个文件的固化，可以做到比svn更细致的控制。换句话说这也是svn的优点，SVN相较于VSS、CVS有几个显著的区别，其中最重要的特性之一就是原子性提交，每一个提交都是由多个文件的修改组成，而且这个提交是原子性的，要么这些修改全部成功，要么全部失败。

SVN的分支管理，把每个目录做了一个单独的拷贝，非常占用服务器空间，好处就是分支没用之后，直接把目录删掉就好，大概这就是所谓的易于理解吧。在第三代面前完全不够看不说，我认为甚至还不如CVS。尽管CVS说起来有很多缺陷，个人使用已足够。

第三代的引领者BitKeeper在2002到2005年被用于Linux内核开发，后来针对特点，开发出了Git。除此之外Hg也广泛被认可。配套的还有工作流程的变化(Integrator workflow积分流)，这才是称之为第三代最大的原因吧。

名为分布式管理，但是千万不要认为各分支平等，这其中就有一个更平等的分支，或者叫blessed repository，由项目的管理者持有。如果想把改动合并到这个`reference`分支，发起一个request，只有管理者pull并merge这个请求，才算合入。所以分布式开发模式经常会看到`pull request`。这种模式改变的是存储方式，但代码的管控仍然是严格的。