批处理的用法
==
基本语法
--
分支和判断，如果是字符串比较，一定要两侧加双引号。

```
if "%1" == "" (
  command
) else if %1 equ 5 (
  command
)
```

变量捕获

网上说通过重定向到文件再`set /P a=<xx` 方式读取回来，一则看上去不优雅，更麻烦的是前一步写入的文件在此时经常会读不到，原因不明。最好的方式还是用`for /f`语句。

```
for /f "delims=#" %%A in ('your commad %*') do (
  set VAR=%%A
)
```

只有for的/f选项才能在SET中执行命令，否则只会当作字面量或文件名来解析，其次command要用单引号包围，其中的%参数会正常解析，最后变量一定要写两个%（只有在cmd直接输入允许一个%）。/f后面的选项可以为空，默认会按空格会Tab对内容进行切分，如果希望不切分，找一个不会在内容中出现的字符作为切分键，但无法用\n，因为会被识别为\和n两个字符。另外for语句支持嵌套。整个语句看下来，将输出先按行切分，再进行行内切分，值赋给一个变量，接下来用这个变量，用法有一点像awk的getline函数，甚至连选项名f都和awk一样。

函数用法
--
用 :func 加 goto eof的方式可以定义一个块，但它还算不上函数，如果执行流到了定义开始处，会继续执行块中的语句，这显然不是函数的行为。根本原因是批处理只能按规定执行(顺序或跳转)，不具备全局哈希表，无法把一个块从执行流中摘出来。所以我能想到的办法，把所有要定义的函数放在最后，然后在第一个函数前加上一句goto eof防止函数被执行。把主执行流程写在开头。

这种做法能行得通，多亏批处理有call机制，函数执行完，能接着上一句call继续走下去。

从中可以得知，函数最朴素的实现，便是开始标记、结束标记、执行后的返回地址。和汇编指令没有区别。

命令中经常能看到类似`%~dp0`的符号，分开解读它。最初的原型是%0，执行命令本身，如果%后面是~符，表示对变量参照进行扩展替换，有一系列的修饰符，d表示盘符，p表示路径，n表示文件名，x表示扩展名，详细文档可以用`for /?`看到。

从命令行交互使用set /p var=[prompt]方式，之后用%var%就能得到用户输入。

WSH和COM
--
Windows Script Host，对应cscript.exe和wscript.exe两个程序，但这俩只是壳，最终要根据脚本的后缀加载不同的dll。比如.js就加载jscript.dll，官方只有vbs和js，如果安装了ActivePerl这类包可以加载perl.dll并用perl语法写脚本。

如果只是这样没太大意义，它还封装了COM技术。从顺序上来说，是这样的

OLE1.0 -> COM OLE2.0 ActiveX

在js中用new ActiveXObject可以获取COM对像，进而操作宿主中的Office对象，这也体现了COM底座的价值。可惜时移势易，这两项技术只做为维护内容，不会再投入新的开发了。