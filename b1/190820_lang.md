# 类型理论

## 变量类型

对变量来说有几个属性：类型，可变性，作用域

1. 类型，动态语言不需要事先声明，所以这一点是没有的。C或Java需要，(C++11的auto看似做了简化，其实只是给编译器的一个提示，还是会转变成真实的类型再编译)

2. 可变性，纯函数式比如Haskell是不可变的，也就不需要这个修饰。但大量其它语言还是需要的，比较多见的是const/volatile关键字，ES6也引入const了，Lua5.4引入const，Scala是用var和val来区分变量是可更改还是恒定性

3. 作用域，Lua语言在声明一个变量时，是可以指定local的，表示这是一个位于当前chunk的变量，如果没有，则变量被声明到了全局空间，语义上对应js中的var关键字。

local和当前函数的作用域在一起，因此访问速度也最快，全局变量则要依次向上查询，速度显然要慢一些。所以很多Lua代码，都会在开始处用local方式把全局重新定义一遍，目的就是为了提高速度。对于默认声明变量都不在局部域这点，我很不理解，为什么可以在一个函数内部声明一个外部的变量？而且显示调用local声明变量的方式，还可以声明一个变量但不使用。因为这本质上只是预留了一块空间，无非是空间的位置在哪里而已。

RnRS中有这样一句：对变量的每一次使用都对应于该变量在词法上的一个明显的绑定，因此只声明变量而不使用的行为，在Scheme中是不允许的。

纯函数式理论上是不是需要声明变量的，一切都在计算中传递。但冯诺依曼的计算机模型却让变量成为了计算的基础。另外全部做成在计算中传递也比较难以书写，于是Scheme中也保留了局部的变量绑定语法，就是let系。它的作用域就是局部的，可以认为是必须放在函数开头处，且必须显示声明绑定关系的local语句。个人以为这种规定比js中随意放置var声明要严谨得多。

再提一点RnRS对define的定义是Top Level Definition，而let系是Internal Definition。我用TinyScheme测试，是可以在lambda内部使用define语句，但kawa就通不过。考虑到Tiny毕竟是一个极小的实现，对一些限制也不严格，因此对define的使用还是在全局较好。

null最好是提升到类型级别，而不是作为特殊值，编译器会推导保证类型正确，而值只能在runtime时直接崩溃。

Rust 错误处理本质上还是基于返回值的，很多基于返回值做错误处理的语言是将错误直接硬编码到正确值上，或者返回两个值，前者例如 C 在很多时候都是直接把正常情况永远不会出现的值作为错误值，后者例如 Go 同时返回两个值来进行错误处理。而 Rust 则将两个可能的值用 enum 类型表示，enum 是和类型(sum type)，表示两个可能的值一次只能取一个。

## ADT

函数式语言的代数数据类型ADT(algebraic data type)，简单的说就是组合类型。不要和抽象类型abstract data type混淆。

sum type是tagged union(值域是每种field的sum)，product type典型例子是tuple或struct(值域是每种field的cartesian product)。

tuple强调不可变，python用tuple作为函数的出入参，利用的就是immutable，而且因为不可变，一定程度上就具备hashable特质。

拓展:思考元组、函数参数、函数返回值，命名参数和 Record 以及 list 的关系(比如像 SML 那样设计)

## symbol和string

在lisp中符号的历史比字符串更加久远，在LISP 1.5中SYMBOL 和 CONS是最重要的数据类型。

> 数字是一种特殊的符号。——摘自《LISP 1.5 Programmer's Manual》

而字符串是后来加上的。用来表示字符序列的概念，至此，再用SYMBOL的NAME来表示字符序列已然成为不好的行为了。

举个例子`'abc`作为一个原子（atom），不可以拆开；而`"abc"`是复合数据，可以提取出"a"。因此symbol的存在大大扩充了原子世界，以便于写符号计算和元编程。

字符串是无结构的，符号是有结构的，符号中的数字类型也不是以字符串形式储存的而是单纯的数字，原子的符号受到标识符规则的限制而字符串没有。

换句话来说不是任意一段字符串都可以找到相对应的符号。