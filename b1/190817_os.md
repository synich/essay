协程剖析
====
协程的历史很早，随着非阻塞(NonBlock)操作的日渐普遍，每一次非阻塞指令都配套回调，代码可读性很差，于是协程就重新被人捡起。

分为有栈协程和无栈协程俩种，区别在于是否有自己的调用栈来进行函数调用等操作。

有栈协程
----
有栈协程这里的做法比较好理解, 一般来说有俩种做法:

采用操作系统提供的api 类似 ucontext 或者 setjump longjump
用汇编操控寄存器保存状态 典型的例子

无栈协程
----
从上面例子看出，用了OS自带函数做所有寄存器(EIP)和栈上变量的保存恢复，故名有栈协议。 下面给一个C语言实现的模拟操作

```
void coro_func(int& step) {
  switch (step) {
    case -1:
      if (step) {
      terminate_coroutine:
        step = -1;
        goto bail_out_of_coroutine;
      bail_out_of_coroutine:
        break;
      }
      else
    case 0:
      worker(1);
      for (step = 1; ;) {
        if (step == 0) {
    case 1:
      break;
        }
        goto bail_out_of_coroutine;
      }
      worker(2);
      for (step = 2; ;) {
        if (step == 0) {
    case 2:
      break;
        }
        goto bail_out_of_coroutine;
      }
  }
}
```
可以看出，把阻塞操作拆成两步，在执行完NonBlock后更新步进值并退出，下次自然就能回到上次的点继续。不依赖系统调用。

以下是其他人用Python实现的无栈协程

无栈协程的实现, 要几个条件:

1. 栈帧内保存的不是状态而是指向状态的指针
2. 所有帧的状态保存在堆上

为什么说第二点比较重要, 因为理解了第二点就发现, 其实根本不需要上下文切换, 因为全局的上下文就没变过, 改变他们的调用关系就行(栈)

区别
----
有栈协程可以随意的切换, 因为他所有状态都在他协程内部, 并且可以并行 , 存在中间状态比如寄存器的计算结果啥的, 切换要很小心, 但是粒度更细。无栈协程只能手动切换, 不过效率要高, 不用管复杂的寄存器状态, 切换的控制权也在用户手中

对称和非对称
----
用yield/resume风格实现流程切换，叫非对称协程。在让出运行权后并不知道接下来是谁运行。

还有一种对称协程，类似 `f() { core.transfer(g) }`，在函数f运行过程中直接切换到函数g上，但是这种方式写出的代码破坏了模块性，要关心外部的运行流程很难维护。因此目前能见到的协程实现都是非对称。