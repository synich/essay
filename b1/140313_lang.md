数字的精确与不精确
====
很久不写Scheme，写了个判断质数的函数却永远返回成功，看代码逻辑看不出问题，于是只能一个个函数去试验，好在Scheme交互式写法很容易就能逐个函数地检查问题。终于发现问题出在数字运算的精度上。

简单的质数判断逻辑是从2开始，直到这个数的平方根为止挨个去试，如果有一个能被整除，就不是质数；反之就是。但取余是个整数运算，而平方根的结果就算做了取整依然是浮点数，于是用浮点数对整数取余的结果，哪怕它实际上是0，但反应在浮点数里却可能是37e-52这种结果，而这和0是不相等的，导致每次计算的判断都为假，最后这个数就被作为一个质数报上来了。原因找到后，只要在开平方取整后，再做个inexact->exact的操作就可以把浮点变成等值的整数。计算结果也就正常了。

出这个错的原因，一方面因为Scheme是弱类型语言，而在强类型语言里浮点和整形计算是要做区分的，像C会报类型不匹配警告，而ML则干脆就区分了整形和浮点数的运算符，但Scheme是在运行时悄悄地执行，也不报错。难怪历史上总有弱类型语言容易出错的报怨，大家也都是一路吃着苦头过来的。另一方面在RnRS里有一个完整的章节就用来描述数字的概念及相应的操作，以前看的时候不明白为什么要花费这么多笔墨描述数字的概念，以及那一族奇怪的exact?,inexact?inexact->exact，这回算是彻底明白了。正因为Scheme弱类型的特点，需要人为地判定并做显示的数字类型转换，才能得出正确的计算结果。

说个C语言的浮点数处理，float/double是可以memset的，结果就是0.000000。估计也是为了兼容吧。