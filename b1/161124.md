X509证书与GPG验证
====
证书定义
--
加密体系中证书是非常重要的一环，最有名的标准就是X.509。它使用ASN1格式描述，这个标准有3个版本，主要用的是V1和V3版本。证书大小通常在1K字节左右。

X509证书有几种格式，openssl默认使用PEM格式(Privacy Enhanced Mail)，而12306则使用了DER格式(Distinguished Encoding Rules)。DER是ASN.1这种二进制编码标准的一个实现方案(还有一种叫BER)，C函数中的`d2i_X509`和`i2d_X509`，d就代表DER，i则指internal，即C的struct格式。用openssl看的话，要加上-inform der才能正确地打开。

证书的开始是版本号(1或3)，然后是证书序列号(Serial Number)。序列号是整数形式，比如：ab:a5:7c:fb:27:3c:50:91。是个64位数字。虽然名字叫序列号，但不能只靠这个做惟一区分，因为X509标准只要求序列号在同一个发行者或者颁发者(Issuer)下惟一即可（通常是每签发一个证书就加一）。
接下来是签名，签名算法一般是非对称+散列，比如sha1WithRSAEncryption。再是发行者，Issuer有很多个字段，其中必须有的是C国家，ST省，O组织，OU组织单元和CN通用名称(CommonName必须是域名，比如`*.waer.com`)。比如发行者就是德国某州的Apache测试组织。组织后面是证书有效期，包含不早于和不晚于两个时间点。然后是主体或授与者(Subject)信息，同样有C国家、ST省份、O组织等类似的部分，身份介绍后是授与者的公钥，比如1024bit的RSA公钥，这部分显示时似乎总是以00:开头，然后是RSA的exponent，0x1001。

最后是整份证书的签名，否则无法证明公钥及其所有者的信息一致。这里再次用了sha1WithRSAEncryption方式，计算方式我猜测是这样：
先用sha1计算，然后用私钥生成签名，拿到证书的人，用公钥解密后的值，和证书的sha1值比对，只有对上了，说明这份证书才是正确的，防止被人伪造。

上面列的字段都是X509的V1版本，V3在签名前面还会多出许多内容，从结构和原理上差不多就是这些。V3多出了扩展(颁发机构，CRL，使用者密钥标识)，关键扩展(密钥用法)，属性(指纹和指纹算法)。

一份数字证书，最核心的内容就是这几件事：

1. 谁给你签发的(Issuer)
2. 证书有效期
3. 你的身份是谁(Subject)
4. 你的公钥，用于通信时交换密钥
5. 使用签发者公钥对以上信息hash做的签名，防伪造

X509覆盖的范围比较多，从头文件看，除用于认证的X509，还有CRL(证书吊销)、REQ(证书申请)、NAME(证书持有者信息名字)、ATTRIBUTE、EXTENSION五种扩展功能。

证书签发流程与自签证书
--
PKI体系的证书存在链式依赖，下游证书由上游证书签发，最顶级的根证书没有签发者，只能是自己给自己签发，但因为各种浏览器都集成了这些签发者的公钥，所以仍被认为有效，反之如果签发证书使用的顶级公钥没有被集成进浏览器，就会提示用户有风险。12306的根证书就是没有被广泛集成进浏览器的自签发证书。使用证书给别人签发证书，就是上游签发。

从上一节数字证书包含的内容来看，包含两个不同的公钥。当我们在学习做自签发证书的时候，为简单起见，这两个公钥会用同一个。下面来看步骤：

1. 第一步生成私钥，RSA用`openssl genrsa`命令，ECDSA用`openssl ecparam -name secp521r1 -genkey -param_enc explicit`。带上`param_enc`的私钥会把参数都嵌入，体积大一点，否则只有曲线名称，但遇到版本不匹配时，可能无法构造曲线。另外如果担心私钥泄密，还可以在生成私钥的时候用AES-CBC或其它算法对私钥进行保护。得到的私钥文件已经包含了公钥信息。虽然有了私钥，可是没有任何表明身份的信息啊。
2. 第二步生成证书申请，使用`openssl req`，这步要输入上一步生成的私钥。如果没有私钥，你的申请信息就可以被随意篡改，这显然不是证书的本意。申请文件一般用.csr作为后缀。
3. 最后一步签发证书，用`openssl x509 -req -signkey`命令，signkey是自签名的关键，生成的就是根证书了。还有另一种生成自签名证书方式，把申请和签发证书两步合二为一，命令`openssl req -new -x509 -days 365 -key keyca.pem -out pubca.pem`。

有了自签发的根证书，服务器证书类似，第一步先生成私钥，第二步也是生成申请，其中带上服务器的信息，第三步将申请和服务器的公钥交给根机构，由根机构用根私钥对服务器申请加密，输出的文件就是服务器证书了，这时用的命令是`openssl x509 -req -CA -CAkey`。和自签名的差异是参数从signkey换成了CA和CAkey。从这个流程看，证书显然包含了信息和公钥。

还有另一种签发方式`openssl ca -keyfile keyca.pem -cert pubca.pem -in svr.csr -out pubsvr.pem -days 99`，这种方式有几个限制

1. 必须在当前目录下创建demoCA目录，这个目录内还要有newcerts目录，空的index.txt文件、内容为01的serial文件。
2. 根证书（自签名证书）和申请者的Province和Unit必须一致，否则无法签发。

最后看一张图了解客户端对证书的认证过程

![x509-verify](/img/x509-verify.png)

使用GPG来验证文件
--
常见的方式有MD5验证，但是问题在于你怎么确信看到的MD5就是真实的呢？使用更高级别的GnuPG吧，它是符合OpenPGP标准的加密软件，可以加解密，还能签名或验证。最早由德国人开发了PGP软件并大受欢迎，但由于是个商业软件，就出现了OpenPGP标准，而gpg则是最广泛使用的实现，全名GNU Privacy Guard，名字如此相似，不知是故意还是巧合。

先从最常用的验证说起吧。签名文件一般是.asc或.sig结尾，命令行很简单

* gpg2 --verify check.asc filename

签名文件放在前面，在这个流程里还是依赖一个中心化的公钥服务器，比如Openresty的声明如下：

    releases are signed by the public PGP key A0E98066 of Yichun Zhang

可以在pgp.mit.edu网站查到，A0E98066是RSA key ID，可以检索。不知道这算不算PKI。