软件可靠性硬件可靠
====
通常我们在写软件时，总会做各种各样的错误或异常判断，比如输入非法啊，执行异常之类的。但我们很少去怀疑是不是硬件本身出现问题，仿佛这个世界，只有逻辑错误而不会有电路错误一样。

以前听一次云存储的入门讲座，其中就讲到硬盘的存储位出错机率是10e-12，换算下来一块1个T的硬盘，在一年里总会发生一次非正常的bit位翻转。那是我第一次听到有人这么仔细地计算硬件错误机率给软件设计带来的影响。

今天在吃饭时，又听到两个有意思的异常问题

1.软件经常莫名其妙地死机，甚至一天之内死机十数次，经过调试发现总是内存地址的最高位变成错误的1，把1改成0就不会发生死机。从软件层面问题已经无法解答，最后硬件部的人承认是电路设计有问题，类似是电磁兼容一类的，导致内存受影响，引起最高的bit位翻转。

2.某个版本的主程序启动后，会引起busybox死机，但只在那个版本上会出现，经过反复调查，最后偶然发现死机版本的busybox的内存映像竟然和静态编译出的汇编代码不同。考虑到其它版本没有问题，排除加载器问题，于是只好对主程序的内核调用一条条地排查，最后果然发现是某条内核调用，因为代码写得不完善，将某一内存地址的bit位做了翻转，而busybox正好加载到该内存地址。通常code页的内容是不可修改的，但因为这个奇怪的bit翻转，导致汇编指令从Mov变成了Shift，进而导致后续的内存映射异常。又因为异常的内存地址是编译期固定的，所以只在某个版本会影响到busybox的代码段，引起奇怪异常。

这两个问题我没有亲身参与，具体细节也是听说而已，但却让我对软件的底层可靠性有了不一样的认识。平时我们写程序，一般是不考虑内存bit位异常翻转，一方面民用的内存、主板在出厂前还是做了相对完善的检验，电磁兼容也必须要通过3C认证，故这种问题反映较少，但公司产品，尤其低成本平台，研发周期又短，发生这种问题，也就不足为奇了。

第二个问题则是系统层的奇怪异常，以前我自己写代码，如果遇到底层的函数异常，一般也就不去深究了，一方面是信任，另一方面也确实是看不懂。但从实际情况来看，只要是人写的代码，不论它在哪一层，都有出错的可能。

以前还听说过IBM的Z系列大型机，用在金融领域，有个特性就是两个一模一样的CPU同时计算，如果计算出的结果不一致，则丢弃该次计算，当时我看到这段介绍，觉得根本就不可能，今天再去反观，才发觉自己真是见识太少。