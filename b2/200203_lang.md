# [翻译]funarg问题

很多新的编程语言都支持function as first class特性，即函数可以像普通的值一样传入或传出。但函数和变量有个最大的区别，函数会引用变量，如何保证变量的生命周期就成了问题(因此称为function argument，即funarg问题)。具体的困难在于，定义函数的环境和执行函数的环境是不同的，标准的解决办法要么禁止这种引用，要么创建闭包。主流语言的实现方式简列如下

这个问题细化又有两种分支，向上funarg(函数调用返回函数)和向下funarg(把函数作为参数传递给函数)。

## 向上funarg

总共有4种方式

1. 一种简单的做法是把变量保存在堆上，然后用GC回收，一些scheme实现这么做。但这样效率不如在栈上，且显著地增加实现复杂度，对没有GC的语言非常困难。
2. 逃逸分析，在编译期做筛选，只对涉及向上funarg的创建堆上变量，其它就不用管。
3. 在创建闭包时把值复制到闭包，但这只适合不变的值，比如ML和Java就是这种方式，ML的变量全是constant，对java来说“引用”的东西必须是final的，否则被改了之后闭包里的值不会更新。
4. 显式指定引用的变量，把指定的扔堆上，比如php的use语句和object-c的\_\_block

## 向下funarg

这种情况由于上层的栈还在，引用通常不会造成问题。但对于tail-call和CPS风格的代码，会有额外的工作量。此时不能简单地完全把栈替换掉，否则会触发变量无法找到的问题。相比向上funarg，向下并不是什么难题，因此Pascal语言支持向下funarg，但不支持向上funarg。
