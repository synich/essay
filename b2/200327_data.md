# 数据库计算理论笔记

事务和隔离级别
--
Jim Gray于1970最早提出事务的ACID特性，虽然它们并列为四大特性，但重要程度并不同。

* A 原子性，单机版已经很好地解决了这个问题，但分布式环境似乎仍然无解
* C 一致性，只描述了最终的效果，过于宏大也没有提出具体的措施，因此更像是个衍生结论
* I 隔离性，事务中最复杂的特性，分了多个隔离级别，较低的级别其实是在正确性上做了妥协，将异常结果抛给应用层解决，从而获得更好的性能
* D 持久性，它的核心思想是应对系统故障，由此衍生出诸如WAL日志、日志同步/半同步、共享等多种具体技术

可以说事务模型的发展过程就是隔离性和性能之间平衡的历史，甚至可以说隔离性是事务核心。

SQL92定义了4种隔离层级，不久后Jim Gray于1995年发表了经典论文《A Critique of ANSI SQL Isolation Levels》，正式提出了快照隔离的概念。同年Oracle很快就做出了回应，但它的First Update Win方案却不同于《批评》的First Commit Win方案。顺便说句PostgreSQL也和Oracle一样用了FUW方案。早期的MySQL存储引擎并不支持事务，InnoDB出现的时候，计划基于IBM的Aries算法做出MV2PL（多版本两阶段锁），但有学者在2009年基于此改造实现了快照隔离和串行快照隔离SSI，虽然如此但MySQL官方并不支持SI，只是做了可重复读RR。反倒是PG吸收了学界的成果，把SI和SSI合并到产品中。

SQL92之所以不提快照隔离并不是想不到，而是因为当时的实现主要基于锁并发，而快照隔离的基础是MVCC。当然到了现代，MVCC已经成了一种底层技术，用来高效实现乐观或悲观并发控制。乐观和悲观的区别就如字面意义，通过两段简单的代码来展示区别

乐观控制

```
select * from goods where id = 1   -- 不加锁读
begin; -- 读之后开始事务
update goods set stock = stock - 1 where id = 1 and stock = cur_stock;  -- 更新时要注意 where 条件 “stock = cur_stock”，只有程序中获取到的库存量与数据库中的库存量相等才执行更新
commit;
```

悲观控制

```
begin;  -- 先打开事务
select * from goods where id = 1 for update;  -- 读时用for update对数据加锁
update goods set stock = stock - 1 where id = 1;  -- 写时不再校验
commit;
```

可能是单机数据库的历史原因，也可能是应用层为了快速开发，占据主流还是悲观控制。

一致性协议
--
数据在多节点间的同步，应用较广的有这几种协议

* 两阶段提交，即prepare和commit，要求所有节点都一致，高可用性不足
* paxos/raft，中心化广播协议，前者是论文的提法，后者则是后来另一篇论文给出的几乎完整实现。可以看作是复制协议的一种，属于多数共识算法，大部分节点可用即通过
* gossip协议，适用于P2P网络的同步协议，在节点非常多的时候，paxos负担会很重，这种场景用gossip更好

分布式
--
CAP三者只能选其二，也可以只求一个达到最大化，没有见过实际例子。

* 取CA，又名强一致性 ACID，但是分布式系统必然要求P，所以可以把ACID和传统单机的数据库等同
* 取AP，又名弱一致性 BASE，从命名中也能看出舍弃了C，在不追求严格准确（或者说始终最新）的场景有一定应用
* 取CP，用得最广，似乎没有专门的一致性定义

CAP和ACID的C，中文都叫一致性，但两者含义稍有不同。CAP的C指多副本、单操作的一致性，而ACID的C，在最初的论文定义中是指单副本、多操作的事务一致性。

数据分片
--
分片是单机分区机制在多副本的一种扩展，有两种

* Hash分片，为做到适应扩容，都会用一致性Hash算法。这种做法平衡性好，但业务不敏感，扫描时必须全副本都执行，归纳起来就是写性能出众，但读性能较差
* Range分片，原生的分布式数据库多采用这种方案，多个分片间使用raft协议组成Group组，每个Group是最小的高可靠单元

Sort和Shuffle是MapReduce上最核心的操作，由于MR每一步都会写磁盘，因此任意节点都能恢复，同样的，只要做足checkpoint也能非常健壮。