lisp的3个处理阶段
==
看似简单的表达式解析，其实细分为3个阶段

1. 读取期read time，将外部文本表示解析为语法对象syntax object，标记出宏，在下一环节处理
2. 编译期compile time，此时已全部是syntax object构成的列表形式，进行宏展开。由于没有求值，替换是在语法对象层面
3. 运行期run time，将函数和参数按顺序求值，得到最终结果

大部分字符在读取期和编译期的呈现是一样的，但是如表示字符串的双引号，表示数组的#，会导致一段文本变成不同的语法对象，进而影响编译期的处理。或者反过来讲，编译期的对象，可以想象成是struct，有多个维度。而文本表示则只能是平铺的，之所以会混淆，往往是维度单一的语法对象（最常见的就是变量名）。

从文本表示到语法对象的变化，由读取宏来完成（lexer阶段）。quote简写形式单引号，就是典型的读取宏，具备递归能力，比编译期宏更强大。

还有一种compiler macro不是普通的宏，compiler macro是可选的对函数进行优化的提示，CL规范里甚至规定可以忽略compiler macro。