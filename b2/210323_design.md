# 图灵机与lambda演算比较

计算模型的一个重要用途是研究complexity和程序的效率。比如在图灵机模型上你可以简单地定义状态转移为时间意义上的“一步”，程序使用的纸带大小为空间上的消耗。 然而 λ-calculus 上没有特别简单的cost model让你可以直观地谈论时间和空间复杂度，这很大程度上限制了 λ-calculus 作为一种描述算法和复杂度类的元语言。

图灵机也是做不出来的.. 因为长度是要无限的... 有限长度的图灵机和 DFA 是等价的，也就是其实和 λ 演算是不等价的。等价只是从可计算性和多项式时间内的可计算性来讲的。要论上具体数量级和系数，基本上没有哪两个计算模型是完全等价的。

虽然现代程序语言是图灵完全的，但是和图灵机本来的操作方法是差了非常多的.. 如果要写得像一点的话估计就是 goto 指针满天飞舞的情况.. 和现代编程体验也是差了不知道多少的..

甚至现代程序语言的“函数式”趋势我也都觉得本质不是往 λ 演算方向走，而是类型系统，还有就是尽量去写成状态机了。

除了图灵机与λ演算外，其实还有许许多多的计算模型，它们都等价：

* 图灵机
* λ演算
* 一阶逻辑
* 时序逻辑MPTL
* 动态逻辑
* petri网
* 进程代数
* 递归可枚举语言

这些计算模型都是相互关联有所侧重的，比如说图灵机能接受的语言是递归可枚举语言，一阶逻辑的归约是λ演算，一阶逻辑的扩充是时序逻辑、动态逻辑，进程代数关心迁移而图灵机关心状态。

这些计算模型能力都等价，它们从不同的视角去看待计算这件事情，面对着不同的问题，采用不同的计算模型效果是不一样的。在有些问题里面，用图灵机就表达不清楚，但是用递归可枚举语言就能很好地解释。图灵机需要知道系统内部状态，而进程代数只需要关心交互过程。动态逻辑和petri网能给出计算的全局状态，而时序逻辑、图灵机、进程代数则“只见树木不见森林”。

最后，我只能说，针对合适的问题，有合适的模型。“普遍接受”是因为见过的问题少了。

希尔伯特最初提出 23 个问题的时候，对计算问题只是大概说了一个「mechanical」，当时谁也说不定「machanical」的形式定义。图灵的模型无疑更接近「mechanical」的本意。而且后来图灵从哲学上把图灵机和人脑做了一些比较，也得到了业界的广泛认可。这些在图灵的传记《Enigma》里专门有描述。特别说了图灵发现 Church 的论文首先被 reivew，非常沮丧，但是最后评议还是认为图灵的模型更有创意。

考虑到硬件结构、空间复杂度等问题，自然数不会用church encoding表示，递归也往往不会真编码成Y combinator 。虽然有个东西叫De Bruijin Notion，可以把lambda term编码到形似0101的二进制形式。。

Lisp Machine也是建立在Von-neumann体系结构上的，只不过用专用硬件、指令加速某些操作，比如用List处理器高速完成动态类型检查，专门的List存储器实现树状的表存储，把nil之类的常量存到专用寄存器，对某些结构并行求值。。

各种Abstract Computing Machine（CESK、CLS、SECD 等）的提出、编译技术（譬如CPS、Defunctionlizing变换、LISP-2 GC）的进步、以及体系结构的发展（内存、微处理器等），使得普通PC上也能准确、高效地实现函数式语言。

最后实际普遍使用的computation model是Von-neumann模型，都带着可随机访问的内存。很少有真拿一条纸带左右移动算东西的。Von-neumann能流行，主要是因为这个能用电子元件做出来，而且速度和其他能做出来的model比要快不少。
