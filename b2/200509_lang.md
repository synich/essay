# 代码写法中的状态与异常

最近在做构造数据的工作，代码是另两人写的python，在改造过程中，修正了我以往对对象和异常的认识。

以前写代码既不爱用类和对象，也不用异常捕获，这次造数据的代码全部是定义各种函数和调用，用法不复杂。但造数据的需求很多，从而就导致函数参数非常多，写起来代码非常啰嗦。参数多的另一个坏处是在多处调用时，不容易一致。

有状态的执行体
--
构造表数据需要带入参数，但是这个数据其实是和函数绑定的，完全可以合并到一起，用闭包或对象来表达。函数式推崇无状态，但我不确定闭包是否为函数式所接受，但在具体的工作中，带状态的可执行体是非常有用的。

使用异常
--
有些表数据的构造有依赖关系，如果前置表没有被构造，这张表就不应该被构造。这时有两个选择：

1. 隐式构造被依赖项
2. 返回错误或抛异常

开始想隐式构造，动态构造函数在main函数中被sys.argv给绑定了，于是转而返回错误，至少显示提示也不失为一种选择。如果返回错误，由于表很多，代码会显得非常啰嗦，所以想到用异常。异常有个好处，具备穿透性，不管层级多深，可以直接穿过多层直到被捕获的地方，另外异常还必须要能携带值，否则只有异常类型，捕获了也无法进一步处理。python3的异常语法和2不兼容，似乎只能带str类型的变量，于是通过这条路径，把缺失的表名用异常抛出来，在main函数中显式地补上。

反思这次的代码修改，以往偏好理论派的东西其实在实际工作中并不能很好地应对。以我现在的状况，也不可能在理论上有太多的造诣，让更多实际的代码能写得优雅，利用好常见语言的特性，更为重要和实际。

模拟的隐患
--
Python的异常没有ruby的retry机制，为了模拟在try块的外围加了一层while循环，并在except里用count计数累加，保证重试N次后能退出。但过了一段时间，又加了一个种异常捕获，这里忘记对count累加，导致循环无法退出。模拟的方式终归只是权宜之计，最好的办法仍是以DSL配套完整的机制才可行。