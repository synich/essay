# 21 C++类的访问控制符与引用

by 180413

`C++`类的public/private是范围式的，从一个声明符直到下一个声明符之间的所有变量、函数的可访问性是一样的。而Java是针对每个函数需要显式写出访问控制符。初看之下似乎两者没有大的区别，甚至`C++`的范围式控制还可以少打几个字，直到最近我才意识到`C++`的控制方式在隐藏信息上存在的缺陷。

比如声明一个接口类，通常来说最先思考的肯定是类的对外可以提供的功能，即public区域的函数。定义好这些函数后，就开始着手实现。但是在实现的过程中，如果公开函数的语义包含的操作较多，肯定会进行拆分，这些被拆分出的函数当然是private级的。但是当你在cpp文件进行函数拆分后，却会遇到代码无法编译通过的问题，原因就是在类声明中没有定义这个private函数，于是一方面，你要切换到.h去声明这个仅仅为了可读性而提炼出来的函数，而且可能因为函数命名比较随意，直接暴露出去又不是本意。

为什么在编译器层面，不能省略声明呢？还是由class的特性引起的。由于对OO特性的理解：封装、继承、多态，这3大特性被语言级别地支持了。封装就体现在public/private上。如果一个函数没有声明就直接实现函数体，编译器不能也不敢随意地给这个函数确定可访问性，于是这个问题被抛回给了代码编写者。因此类的每一个细节就必须在头文件中暴露出来。这也是为什么`Effective C++`这么推崇pImpl法则的原因。

所以`C++`的访问控制只是阻止了人为的调用，但无法阻止人看到内部函数。要想完全地隐藏细节，必须先声明一个只有public的函数，然后在实现时，继承这个类，把私有函数在继承类中声明，这个继承类不公开，如此才能做到细节的隐藏。

反观Java，由于访问性是函数级别，完全可以在实现时直接把这个被拆分的子函数声明为private。话说Java好像也没有头文件和实现分离这回事。

## 引用

「引用」是被 operator overload 逼出来的。在 operator overload 出现之前，Bjarne Stroustrup 从来，从来没有想过要引入「引用」。因为引用的所有用途都可以被指针代替。

而且 Bjarne 是最烦增加新元素的。像 C++14 里那个「= delete」我以前都没想到这辈子能在 C++ 里出现。因为 Bjarne 当年死认为把 constructor 放到 private 就行了。

「引用」也不能防止空指针。大型代码动辄传递指针引用好几层，其中完全可以有一层是空的。具体代码我就不放了。

自从 Bjarne 铁了心要做 operator overload 之后，一个问题就是像 「=」，「+=」这样的自修改操作怎么传参。你要不要写成：

A a;
&a += 1;
这哪行？（上面这种代码是 Bjarne 论证引用的必要性的时候自己在书里写的。）

所以就有了引用。

至于其它用法都是废物利用吧。