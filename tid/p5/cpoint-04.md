# 04 指针的三种面貌

by 180920

起因是同事发了一段C语言的汇编代码，理解不透，代码如下

```
ifAddrSt = ifAddrSt->ifa_next;

0x00000000004006a5 <+221>:  mov  -0x10(%rbp),%rax
0x00000000004006a9 <+225>:  mov  (%rax),%rax
0x00000000004006ac <+228>:  mov  %rax,-0x10(%rbp)
```

能看出把rbp-10位置上的值做了一通操作后赋值回自身，但是为什么是两次取地址非常迷惑。

在分析汇编之前，先想明白指针的几种表示和对应的汇编形式。先说普通的变量，比如最简单的`int i=1;`这条语句，i就有两种形式，i和&i。&i是i这个变量的地址，对应rbp加减一定的偏移量。实际代码中很少会用到&i，大多数时候都是用i，也就是&i地址存放的值，这个值对应的汇编就是(%rbp)。

说完普通变量，再看指针。指针除了上述两种形式，还多了提领`*`操作。因此对于`char* p;`，rbp就对应&p，(rbp)才是p。`p->next`的操作可以等价为`*p.next`，因此才有了刚才汇编中的前两句，对rbp做了两次取址操作就好理解了。

1. 第一句(%rbp)将ifAddrSt放到%rax寄存器
2. 第二句等效的C语言是`*ifAddrSt->offset 0`，所以(%rax)就够了，不需要偏移
3. 第三句将值重新写回ifAddrSt，此时不用提领%rax，值写入(%rbp)。