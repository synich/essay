# 02 协议工作的反思

## 协议该如何演进 at 16.08

协议岗位作为职能部门，工作本身不容易出彩。出了问题会被追责，做得好无非就是不出问题，但不出问题这个标准在组织内部是没有意义的。

曾经有比较理想化的言论，协议就像法律，但事实上迫于现场的压力或者设备以出货等名义，妥协是难以避免的。除此之外日常工作中的扯皮、认识不对等造成的心力损耗更是难以承受。

首先要尽可能地团结友方的力量，协议分为服务器端和Web及NetSDK两个客户端，Web隶属产品线且经常被界面牵着鼻子走，通常很难想到一起，但服务端和NetSDK作为同在一个楼层的兄弟团队，想法利益往往一致。两种客户端因为服务对象不同，协议风格会产生差异。

目前的想法还是要区分Web协议和NetSDK协议，往往Web先定义一套协议，到NetSDK实现时，视情况做一层桥接，不把Web协议直接暴露给NetSDK，而是由服务端调整成更纯粹的协议，实现上可以迁就Web。因此必须要有一支能调动肯拼搏的服务端实现团队作为支撑，否则难以落地。

## 处理权限校验问题的反思 at 17.08

公司产品的权限校验问题做了半年，前期我没有参与，最近因为人员调整所以换我来继续处理。说实话对于嵌入式产品却有多达6、70种权限的历史遗留问题，我很不认同。我觉得Onvif的权限模型把用户固定地划分到3个组，同时定义了几个固定的权限等级，语义清晰且一致性也很好。

经过上半年的处理，总算把6、70种权限归约到15种权限，结果产品又开始不停地提增加权限需求，我本来想限制权限种类不允许扩充，想想这样做在理论上站不住脚，还是要思考权限问题真正重要的根本约束(出发点)是什么，以及要达成的归约状态又是什么。

约束点就是每次的请求都需要权限校验。但是仅仅这样，就又会发散成不同产品各自定义权限，导致同一个请求却有五花八门的权限定义。甚至更加粗暴直接的是把权限和Web界面绑定。于是就出现今天开发提交给我的，增加一种日程这个请求的权限甚至包括了存储权限和编码权限，原因就是产品的惯性思维，因为录像和动检界面可以增加日程，所以增加日程的权限也要涵盖存储和编码。这类错误根本不值得讨论。

不同的嵌入式产品最终归约到统一客户端来展现，为了达成操作的最终的一致性，有必要限制权限和请求的关系。权限涉及安全产品线、产品线、协议模块和客户端，各自有各自的诉求，初步设想的处理基调是这样。

1. 原则上每种请求都要有权限，但如果是非敏感信息的只读操作，可以不校验权限，需要知会到安全产品线。
2. 协议模块对每种请求默认只提供一种预先定义的权限，且这种权限就是展示在客户端上的权限定义。多种权限增加使用认知难度，在处理上歧义也很多。
3. 如果产品线不认同这种权限，可以定制请求的权限列表，配合产品的Web界面，可以满足产品需求，不过这样的产品在接入统一客户端时还是会显示异常，终究无法做到全面的平衡。

## 修改能力协议的思考 at 17.12

对一个视频通道获取智能能力的协议，原来的协议只有一条能力，这种描述不足在于能力有当前能力和潜在能力，嵌入式设备的能力不是孤立的，会受制于其它资源，因此协议上要有两个能力。如果只到这里为止，协议就结束了，但接下来的实现就相当地狗血。

因为用了RPC方式，每个协议和接口对接，接口中只定义了一个caps参数，无法把协议的full节点映射到头文件。通常这种时候再增加一个接口，用来获取full能力，并在RPCServer中调用两次把能力返回也是可行的。此时第二个坑出现了，所有的接口定义在类当中，而类的接口数量是有上限的！此时这个类的32个接口都用完了。当然这种情况也遇到过，换一个类增加接口就是了。但偏偏这个类不是管理类，协议调用这个方法是通过工厂方法的instance，并传递通道号来获取类实例指针方式，比如当前的智能类名字是DevVideoAnalyse，客户端会先指定通道2获取对应的实例token，接下来通过token去访问getCaps方法，到了getCaps的实现只有token，无法映射到DevVideoAnalyse2这个实例(因为无法直接得到通道号)！变通的作法是建立token和两个类实例的绑定关系，这样一来又要多费很多周折，且为这一个方法也没有必要。

最后的解决办法是在getCaps的请求中增加一个channel，通过channel重新获取DevVideoAnalyse2的类实例并调用方法获取full能力。当然这样做协议就显得很冗余，也是协议被实现绑架的一个例子。

我一直对先获取资源指针并操作这种模式很反感，协议不应该暴露资源，如果不是这种模式，虽然类有32个接口数量限制，实现上并不会很丑陋。
