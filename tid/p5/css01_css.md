# 01 CSS的一些理解

## 写在前面

HTML是SGML/XML的一种特殊应用或者说DSL，标准的网页写法是`<!DOCTYPE html>`，与之对照的DocBook的首行写法是`<!DOCTYPE article>`，而SVG图像的写法是`<!DOCTYPE svg PUBLIC >`。
(`<!DOCTYPE>`是SGML的语法，和注释语法`<!-- -->`参照就好理解了)。
凡是符合XML定义的文档都必须通过DOCTYPE指定DTD，而浏览器天生就为显示HTML，即使不指定DTD，只要开头有`<html>`标签就默认当作网页来解析了。
既然是SGML系，整体风格都是树状。原生如h1,p,table等标签就属于CSS1范围的选择器，浏览器内建了各种HTML标签的CSS基础样式，因此最简单的网页，哪怕不定义任何CSS也具备一定可读性。当然除了原生的选择器，还有类选择器、ID选择器以及伪类等高级用法(当然对应CSS的级别也更高)，这时就必须由用户指定样式，浏览器只负责渲染。

CSS作为大HTML的一部分往往会被浏览器缓存，虽然在HTML层面可以用一些方法控制缓存策略(比如PHP的setheader或者在HTML用<meta HTTP-EQUIV>>标签强制修改缓存策略为no-cache，但CSS作为外链的附加属性就没这么幸运了。通常的作法是在引入CSS文件的末尾加上?v=1标志，当CSS内容有更改时，则改变v的值，由于CSS文件链接在HTML中，HTML可以控制不用缓存，浏览器读取到新的v值就会重新获取CSS文件。否则只能用Ctrl-F5的方式强制更新，界面才会用上新样式。

前端领域一直在快速变化着，对CSS的认识也有很多流派

## 视口

手机版页面的文字非常小，且经常要来回地拖动。几经查找看到viewport概念，是Apple的mobile safari首先提出，后来各个移动浏览器厂商都跟进了。具体地说在html的head部分加这这样一句，网页效果会如你所预期那样：

```
<meta name="viewport" content="width=device-width,height=device-height,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
```

这里面最重要的莫过于width=device-width和inital-scale=1.0两句，由于不同设备的宽度不同，有了device-width指定可以大致做到不同页面如预期，但如果没有inital-scale，至少在这个博客上会非常难看，正文栏所占的宽度很窄，加上之后所有的内容就正常了。再说一句user-scalable，如果没有这句，每次焦点到输入框，页面会稍稍扩大一点，有种跳变感。再者对手机网页来说一旦可以缩放，反而会来回拖动体验未必就好，不如一开始就把布局字体设置妥当，之后就不必调整了。

## CSS五大主题 up 18年3月24日

第一次学以为CSS就是布局，随着看文章变多，才知道范围庞杂，至少包括

* 样式: 范围最广，包括但不限于颜色/字体
* 数字/单位/函数
* 布局: 盒模型
* 层叠和继承
* 选择器: 很难记忆，但它是理解CSS的关键

### 样式

这可能是相对比较好理解的主题，也是最早就有的内容。HTML5丰富了b/i等各种样式元素，使HTML更专注于语义层面。

value是元素的属性值，比如form控件当前的值。而innerText和innerHTML是元素开始和结束标签之间的值，可能不能编辑，比如div元素。

### 数字/单位/函数

这块内容比较繁琐，也很难记，加上还要考虑各种不同屏幕的差异，细节非常多。

* px/em/rem: 默认字体大小16px，对应1em
* vw/vh: 相对宽高，1表示1%的总宽度/高度
* fr: grid布局的单位

关于px单位，引用hax的解释

>    CSS规定，浏览器应该对像素值进行缩放调节，以保持阅读体验的大体一致。也就是要保持一定像素的长度在不同设备输出上看上去的大小总是差不多。 因此CSS提出了“参考像素”（reference pixel）概念。规范使用视角来定义“参考像素”，1参考像素即为从一臂之遥看解析度为96DPI的设备输出（即1英寸96点）时，1点（即1/96英寸）的视角。 请注意这个差别——CSS规范定义的参考像素并不是1/96英寸，而是1/96英寸在一臂之遥的看起来的视角。通常认为常人臂长为28英寸，所以其视角可以计算出来是0.0213度，即(1/96)in / (28in * 2 * PI / 360deg)。

可以看到px和物理分辨率并不等价，对PC而言，由于人眼和显示器的距离与CSS定义基本一致，二者近似划等号；而手机的分辨率虽然高于PC，但仍然要符合规范，因此手机屏幕宽度px值会比分辨率小很多，具体多少px由每个厂商各自定义。从而保证了16px字号在不同显示设备上看起来的视觉效果是接近的。

函数只有预定义函数，比如counter/calc可以进行数值计算，url则可以进行外部资源的导入。要想添加自定义函数还得靠预处理器。

### 布局

盒模型包括margin, border, padding, conntent 四个部分。差别是对高宽的范围定义。

CSS最初并没有定位在布局功能，只是意外地发现盒模型配合float可以实现布局效果，但用float方式不仅需要很多hack手法，还破坏元素间关系，所以增加了flex和grid作为更专门的布局手段。

规范定义的盒模型只有block和inline两大类，block的原始语义是一个元素占有一行，主要有div/list-item/table这几种。block能内嵌block/inline，而inline只能内嵌inline。（题外话：由于table的历史比CSS更早，所以CSS用在table时，会有特殊的地方。再提下CSS与HTML历史的兼容性，由于CSS出现得比HTML晚，因此它一定要把HTML中所有的元素的特性纳入到自身的体系结构中。比如HTML的head标签不会显示，对应盒模型的属性就是display:none，不会影响布局，而body就是display:block，作为顶层的BOX容器呈现。任何新生事物都要能包容已有系统的能力，才是可被推广的系统。）

和布局相关的三个关键字的优先顺序为display(不为none)>float(不为none)>position。CSS早期的术语来自印刷排版，被用于布局的float就来自印刷的图文混排，而position虽然字面意思就是定位，有relative、absolute、fixed等多种方式，且确实能实现精确定位，但强依赖尺寸计算，有些场景反而不如float好用。

float用在布局时，一个父div内顺序放置多个div，每个div都设置成float，宽度未满时从左向右排列，如果宽度达到父div的上限，另起一行排列。举例来说，如果父div的宽度是90%，第一个子div是50%，第二个子div是40%，这两个就在同一行，如果第二个也是50%，就会被挤到下一行。

归根结底本来每个div单独占据一行，如果想让多个div在同一行，就要破坏div的block特性，让想处在同一行的多个div能float(漂浮)起来，注意必须都float才行。一旦这样块之间就再不是固定的排列关系，而要取决于div宽度总和，如果宽度够就被放在一行了。如果超出了，还是排列到下一行。排到下一行后，可以用left或right来决定对齐方式。

inline-block方式是对早期bug的一种不得已的合理化。比如有3个顺序的div，如果1和3都是inline-block且总宽度和小于父block，直接把1和3排列到一行里，如果这一行的剩余宽度还能放下第2个div，就放在同一行，否则在下一行排列。但是如果第二个div是float:left，会放在第一个div前面。

### 层叠和继承

两个相近但不同的概念，先说层叠，CSS的C代表层叠，也是CSS与其它布局方式最大的不同。CSS的所有变量定义是全局的，因此必然存在冲突，解决的办法就是层叠的规则。样式来源有5个

* `<a style="">`  属性样式，又称内联样式
* `<style >`  内部样式表
* `<link>` 外部样式表，又名外部样式表
* 浏览器用户自定义样式
* 浏览器默认样式

CSS权重规则的特殊性可以用4个整数来表示，例如1，0，2，0这样一个4元数表示，计算规则从高到低排列如下：

1. 对于内联规则，权重值表示为1，0，0，0
1. 对于规则中的每个ID选择符，权重值表示为0，1，0，0
1. 对于规则中每个类选择符和属性选择符以及伪类，权重值表示为0，0，1，0
1. 对于规则中的每个元素名或者伪元素，权重值表示为0，0，0，1
1. 对于通配符，权重值表示为0，0，0，0.

最终得到结果就是这个规则的权重。两个权重值的比较类似字符串大小的比较，是从左往右依次比较，第一个数字大的规则的权重高。

还有一种层叠，`<p class="A B C">`，这时ABC三种样式会层叠后作用在p元素上，ABC属性的层叠原则，和class属性中的排列顺序无关，而是取决于怎么定义，其中规则非常复杂，这里就提最简单的一种，所有都是单独定义（没有父子、兄弟或important时），最后的定义覆盖早先的定义。如果A最后被定义，层叠的结果就是A。

继承这个特性是由HTML的结构化特性导入的。像color、font-size、font-family、text-align这些属性，会在给父元素设定后传递到子元素甚至孙元素的样式中，这些子元素/孙元素会得到样式的渲染，就是CSS的继承机制。不是所有属性都会继承，像margin/float等都不会继承

### 选择器

由于HTML的树状结构，对元素渲染时一定会遇到对某种具有父子或兄弟的元素采用特殊属性的场景，选择器提供了丰富的语法来支持如何选中树结构的某类元素
