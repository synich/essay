# 01 Lua的表与元表

## 表方法与self参数

Lua的表定义函数方法有两种语法：点和冒号

比如local t = {}，定义new方法有两种写法：

1. function  t.new()  ...  end
2. function  t:new()  ...  end

前一种就是常规的定义，等同于t["new"] = function() ... end，类似于C++的类静态函数定义。但是类静态函数只能访问静态变量，而Lua的这种函数，如果显示传入这张表，效果上就是个普通的成员函数了。第二种则等同于t["new"] = function(self, ...) ... end。类似于C++的成员函数定义。

需要注意的是，如果在表定义的内部直接写函数定义，只能采用第一种写法，第二种带self参数写法是行不通的。因为此时表还没有构造完全，这样写有风险。也就是说对这个表如果两种形式都定义，则因为key值相同，加上Lua的动态特性，后面被定义的会覆盖前面。而C++中如果定义的静态函数和成员函数的参数列表完全相同的话，是无法编译通过的。

采用冒号写法的函数会多出一个隐藏参数self，这个self不属于Lua的关键字，但在冒号定义下会由lparser.c创建这个特殊的局部变量（和self同样性质的还有arg变量，会在vararg函数并开启兼容5.0时自动添加）。如果不想用self这个名字，可以修改lua的源代码重新编译，只是没人会这么做。self的做法和C++的this指针在编译器的行为如出一辙，理解了C++对类成员函数的特殊处理，就能彻底理解self的用意和实现方式。

试想混合两种语法的定义/调用形式，如果用了冒号无参定义，而用点号调用，则第一个self参数相当于置了nil，如果在定义中用了self相关的变量，则这样调用会出错，因为不建议这么用。但这里的self毕竟是个形参，也就是即使这么调了，也没会影响这个表本身，即点号调用完后，表本身内容是不会变的。如果冒号定义有一个参数，但点号调用也只传了一个参数，则这个参数会对应到隐含的self，导致冒号原型中的参数变成nil了。

如果用了点号定义，而用冒号调用，如果是无参定义，则完全一样，如果有参数，则第一个参数就会变成隐含的self，如果在定义点号函数时未考虑第一个参数是table类型的话，冒号调用也会发生类型不匹配，因此在有参数原型的情况下也存在风险。

除非是无参数调用，否则混合调用都存在一定程度的风险，本质上这就是两类不同作用域的函数。而C++在编译期做了检查，不会出现静态函数调用成员变量的问题。

## 理解元表

Lua虽然没有class关键字，但不妨碍它可以模拟OO语言，只是归属到object-based这个类别下(JS是这个流派中的prototype-based一脉)。可以把Lua中所有的table变量认为是object，如果仅仅是这样肯定是不够的，让Lua产生变化的就是元表。

通过一个值的元表可以修改很多操作的含义，但我认为其中最有用的只有3个：`__index(get)`，`__newindex(set)`和`__call`，lua在选择关键字的时候没有太直观。一旦能覆写get/set操作，不仅仅数据得到了隐藏，还能实现delegation，使得语言看起来有了继承的特性，当然也提供了rawget/rawset来访问数据的本来面貌。call则让对象成了仿函，使函数式风格能实现。

在重写这些方法时，`__index`是两个固定参数，self和keyname，`__newindex`再多一个value。而`__call`的参数个数至少有一个self外加可变的参数列表...。共同点是重写函数的第一个参数都是self。

为什么一定会有self呢？因为这3个特殊索引的值都可以是函数，而且还是C风格的plain function。像`__index`的触发条件至少有两个参数，因此像`__index`的实现，可以写成function mt:__index(name)这种风格。如果朴素一点，就直接返回一个变量或新的table，绕弯一点也可以返回function，进而构成链式调用。执行这个function会返回一个table，这个table要先做一次setmetatable，从而使外面使用者看来，就是一个完整可用的对象了。

又比如`__call`能让table当成函数来调用，如果这个table中含有的大量信息不传递到`__call`对应的函数就太可惜了，所以table就成了函数的第一个参数，这是从实用角度出发点得到的设计结果。

前面提到了rawget做点补充说明，正常情况从table访问元素如果访问不到(即值为nil)，就会触发元表机制，哪怕{b=nil}这种形式，访问b时也会查找元表，因为b用pairs根本看不到，所以rawget的结果通常就是nil。

以下是元表设置时的一个小误区

```
local mt = {a="inmeta", __index=mt}
local tbl = setmetatable({}, mt)
```

我开始的设想，访问tbl['a']会得到inmeta，但事实是nil。通过chunkspy反汇编看到`__index=mt`这句对应的是getglobal指令，就是说在构造等号右边的表时，看不到左边的mt，所以尝试向global空间找，当然是找不到的，所以结果是nil。那么换一种写法：

```
local mt = {}
local mt = {a="inmeta", __index=mt}
local tbl = setmetatable({}, mt)
```

似乎规避了刚才全局查找变量不存在的问题，好像也递归地把a设置到元表了，但是访问tbl.a时仍然是nil，说明`__index`的赋值是词法定界，即使看上去把mt重新赋值，但真正查找元素时还是用词法定界时的变量，所以还是老老实实地用`setmetatable({}, {__index=mt})`

## 弱引用

当想要引用一个对象，但是这个对象有自己的生命周期，不想介入这个对象的生命周期，这时候就是用弱引用。典型场景是cache，持有固然好，被释放也无关紧要。

将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。换句话说，只有cache的内容明确地被其他人需要，才会被保留，否则就被GC了。
