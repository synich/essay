# 01 为什么学习Scheme语言

说来惭愧我知道scheme并断断续续地学了十年，但从来没有真正用过，甚至理论都没有入门。虽然记录了一堆，但由于字符串能力孱弱到只能取子串和拼接，导致scheme在CURD领域难有作为，也无法用于web开发。

## lisp族语言与结构化思想

熟悉了vim的sexp模式后，再进行lisp族语言编程，这时操作时脑中思考的就不再是一行文本，而是一整个表达式块，我要在这个表达式外再施加一层操作，又或是去掉这层表达式，而因为表达式的表述如此简洁，在纯文本编辑器中对复杂表达式的引用也能做到十分自然。整个体验完全不同于其它的编程语言。

此处的结构化不是指结构化编程，而是看待代码时，不是单纯的文本，而是一块块结构，编辑、移动、添加和删除的对象，都是以结构的思维去操作。

### vim下的插件操作记录

* <leader>i  在光标所在的表达式之外增加一对括号，并把光标置于前面。I则置于后面
* <leader>w 将光标所在的元素，外包一对括号，光标置于前面，W则置于后面
* <leader>h 将光标移动到表达式开头，进入插入模式，l则光标到末尾
* (或) 光标向外以表达式为单位移动，可带前缀数字
* [[ 或 ]] 顶层表达式是最高级单元，这个操作解决顶层表达式移动的问题
* [e 或 ]e，同样是移动表达式，且把表达式内容用visual模式引用起来

### asdf和quicklisp

asdf类似make，发行版自带，先(require "asdf")再(asdf:asdf-version)查看版本。而quicklisp类似包管理器，要下载文件并用`ecl --load quick.lisp`进入，再执行命令等待。

HOME/quicklisp/目录下保存了包的内容，按代码和元信息分目录保存。

### exit和quit区别

仅在ECL验证过，执行错误语句会进入可恢复区（可以认为是栈深了一层），用quit回到toplevel，而exit不管处在哪一层堆栈，直接退出。

## 3个处理阶段

看似简单的表达式解析，其实细分为3个阶段

1. 读取期read time，将外部文本表示解析为语法对象syntax object，标记出宏，在下一环节处理
2. 编译期compile time，此时已全部是syntax object构成的列表形式，进行宏展开。由于没有求值，替换是在语法对象层面
3. 运行期run time，将函数和参数按顺序求值，得到最终结果

大部分字符在读取期和编译期的呈现是一样的，但是如表示字符串的双引号，表示数组的#，会导致一段文本变成不同的语法对象，进而影响编译期的处理。或者反过来讲，编译期的对象，可以想象成是struct，有多个维度。而文本表示则只能是平铺的，之所以会混淆，往往是维度单一的语法对象（最常见的就是变量名）。

从文本表示到语法对象的变化，由读取宏来完成（lexer阶段）。quote简写形式单引号，就是典型的读取宏，具备递归能力，比编译期宏更强大。

还有一种compiler macro不是普通的宏，compiler macro是可选的对函数进行优化的提示，CL规范里甚至规定可以忽略compiler macro。

## 学Scheme经历的误区

从SICP上手的人往往觉得一个list类型包打天下，以致于看到R5RS中特别定义vector都很惊讶。其实就像其它成熟语言一样，容器有很多分类

* Sequence，顺序容器的统称
* List，特点是长度可变，访问耗时O(n)。含aList和pList子型
* Array，特点是长度固定，在CL中支持多维，访问耗时O(1)。含vector和string
* HashMap，无序容器
* Struct，关联数据

car的返回，更倾向于scalar的值，而cdr通常是list。

mapcar遍历Sequence容器，而maphash遍历Hash容器。scheme原版没有hash，所以mapcar被简化为map，但并不代表这样真的对。

**绑定let和赋值setq的区别**

每个let块会创建新的scope和新的storage place保存值，如果和外层变量同名，以栈的方式实现遮蔽，块结束后弹出从而恢复前一个值。setq复用storage place，实现也简单得多。

从知乎上看到，scheme的意义，觉得写得非常精彩。

在R7RS 88页的篇幅里，塞进了相同尺寸规格的语言无法企及的复杂性。从文法层面的directive, datum label, external representation 与read的联动，到 语义层面的numeric tower, region, proper tail recursion, macro, continuation, environment, evaluation 与eval的联动。Scheme以一种偏执的近乎反实用主义的态度展现了作者的脑洞，回答了这样一个问题：如果有这么一门语言，不用考虑机器实现的便利，不用考虑用户的使用感受，不用考虑设计的可扩展性，尽可能小的篇幅内尽可能多地展现符号操纵的概念，方法，行为和联系。它该是什么样的？
