# 并发和并行

先比较两者的定义：

* 并行是parallel，指多进程可以互不干扰地执行程序，与之相对应的则是串行。如果处理的数据不同，自然不用加锁。并行存在数据的归集操作，Perl6也提供了Promise等原语支持。
* 并发是concurrent，指多个程序同时运行的现象，注意用词，并发的重点在于它是一种现象，至于实现并发是并行，还是快速切换的串行，反而不重要。所以并发就涉及锁是不严谨的，要说对同一资源的多核并发时，才会涉及锁。

并发更多的强调的是有没有这样的能力或特征，它是从事物的性质和对外表现上来说的，它不在乎内部如何实现，相对而言是在更高层次上的概括；而并行则规定了它们在物理上一定是同时进行的，相对而言更严格。

有一本《七周七并发模型》的书介绍了诸如：多进程/多线程的并发模型、异步事件并发模型，Erlang 的 Actor 并发模型和 Golang 的 CSP 并发模型等很多的[[并发编程模型]]。

## 并行涉及的概念解析

并行在软件层面大多是创建线程，线程有两种属性join和detach。pth的线程实现有5个队列NRWSD，分别是new/ready/wait/suspend/dead。join属性的线程在退出时加入dead队列，因此依然被调度，而detach属性的线程则不会，因此直接把线程控制变量free掉不再调度。所以退出时也不一样，join用`pthread_exit`可以捕获退出状态，detach可以直接用return。

条件变量必须配合锁，在wait前显式地获取锁，在wait函数内进入cond等待队列并释放锁，然后线程block住，将将调度权交还系统。直到另一个线程signal或broadcast才重新执行。而signal函数如果发现cond队列为空，不执行任何动作直接返回。

信号量并不是pthread定义的，各个平台函数名也不同，等效于mutex和condition再外加一个计数器的总和。因此mutex和condition可以认为是线程同步的原语。

比如公司的RPC网络框架库，后台启动4个业务线程，平时以semaphore的方式等待，消息到了就在epoll线程执行加1操作，接着就会有一个业务线程被执行。但是这个场景中直接用condition是不行的，试想如果4个业务线程都还在执行中，此时又来一个请求，如果是condition的语义，由于所有业务线程都在执行导致cond队列没有等待，这时的signal没有任何意义，导致这个请求丢失。当然如果真用condition，RPC框架也不是这么实现了。

## perl6对于同步和并发的探索

从slide上摘录要点。

* 线程 存在数据竞争
* 锁 会导致死锁
* 条件变量 spurious wakeups？不清楚是什么

Perl6给出的解决方式，用start启动一个promise，再await就可以得到promise结果。

支持monitor和actor模式，类似Java的synchronizised同步块语法，可见多线程抢夺资源是如此的普遍，编程语言都会作出方便的支持，Perl6提供了OO::Monitor和OO::Actor两种原语。

## 异步接口转为同步接口案例

起因是图片识别人脸的协议最早的对接方式是阻塞的，新品改成异步方式，本来以为异步转同步很简单，真正实做才发现细节值得思考。

首先异步通常意味着执行的结束时间很长且不确定的，但转同步的时候必须要加上限制约不能无限等待，等待的最长时间全凭经验，是无法量化的因素。

接着考虑多线程同步的问题，异步通常需要订阅回调函数，执行并等待的线程A和回调执行结果的线程B间就必然存在资源竞争的问题。常见的等待方式就在是A线程启动一个带超时的信号量(semaphore/event)，并由线程B来释放它。但是如果线程B被触发时线程A的信号量已超时并过期，B就不应该释放。但目前基础库中并没有办法探测A的信号量是否还在等待。因此提高了复杂性。

再进一步考虑，执行函数能否并发执行，如果不能并发则在上层调用前就要加锁防止重入。