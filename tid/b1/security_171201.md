# 一个加密协议定义不仔细的教训

前天下午NetSDK组反馈在AES加密时数据，客户端和服务端对正文的padding采用了不一样的加密方式，导致无法解密。当时就觉得很蹊跷明明已经调试通过的功能，为什么这么久了还报问题。昨天下午花了两个半小时才把问题解决，现在想来都觉得是我接手协议以来遇到最屈辱的一次遭遇。

AES加密是一种块加密，当数据不足一个块时需要填充，和RSA不一样的是，填充内容都常不在算法实现，而是由构造加密数据的人来填充。换句话说AES的API并不体现padding参数，而RSA是明确地预留了padding参数并给出了5种宏定义，这也是当初定协议时遗漏的诱因。

于是想当然地，AES加密时不足部分就填了0x00。可是服务端在实现时从安全产品线得到一份文档，要求采用PKCS7方式填充，但并没有同步给其他团队。为什么需要PKCS7这种方式呢？要从填0x00有什么缺陷来考虑。AES块加密的特性决定了加密后的内容长度一定是16的整数倍，但源数据往往不是16的整数倍，因此接收方得到数据并解密后，需要把最后的padding数据排除掉。如果源数据是字符串，使用0x00来padding没什么关系，都能正确地解析，但如果源数据是二进制数，还用0x00做padding就没法界定源数据的边界。解决的思路就让padding数据自表示哪些是无效的，比如在所有数据的最后一个字节，表示有多少是被padding出来的。举例来说，明文数据是120字节，加密后变成128，多了8字节，加密前就在在明文数据后补上8个字节的0x08（或者补上7个0x00和1个0x08），解密后根据最后的0x08就能丢弃无用的padding字段。

说完原因再说问题，服务端按PKCS7方式处理数据，而客户端根据0x00填充，在源数据长度不是16整数倍的情况下，填充若干个0，而服务端又根据数据最后一个字节向前回退0个字节的偏移（这里处理不严谨，按PKCS7的定义不允许出现尾字节是0的情况，一定是0x01到0x10之间的某个数），由于是0相当于把整段数据交给上层应用。目前协议是用json传输，多几个0没有关系。但当原始数据是16的整数倍时，没有做padding，但是由于json库实现的一些瑕疵，会在最后的'}'后带上'\n'即0x10，在这种情况下服务端把数据回退10，导致上层得到的json数据缺失无法解析。数据长度恰好是16整数倍是个随机概率，测试时也很难发现，导致事情过了3个月才暴露。

整个事故反思下来，教训有三条

1. 制定加密协议时遗留了细节，导致出现流程上的盲点，还是需要自己加强知识学习
2. 多部门间未同步到位，致使关键信息没有同步
3. 服务端实现时未考虑异常情况，不是根据收到数据包来解析数据，而是预设条件导致错误解析