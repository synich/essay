# SQL语言梳理-JOIN种类与选择

## JOIN关联和WHERE谓词

关系代数鼓励把重复的数据拆分，必然导致查询时要把分开的表再合并起来，这个合并的动作在关系代数里称为JOIN连接。连接分交叉连接（再细分出内连接）和外连接（再细分出左连接、右连接、全连接）。很重要的区别是交叉连接时，两张表是对等关系，而外连接有关注表和补充表的区分。回顾一下SQL规范，

* SQL89时没有明确的JOIN语法，而是用逗号实现CROSS连接。
* SQL92时，出现JOIN。由于CROSS JOIN的语义就是笛卡尔积，因此不能有ON条件；而INNER JOIN是笛卡尔积的过滤，必须有ON条件。但MySQL实现得不规范，CROSS，INNER是等价的。JOIN是INNER的简写形式，自然也等价。此时的外连接语法是在从表后面带上`(+)`
* SQL99出现了LEFT和RIGHT连接，而且允许多张表用多个JOIN语句分段写，可读性更好。也因此目前常见的写法都是按SQL99写的

交叉连接可以简写为 FROM a , b，结果是所有连接中最大的，实际应用一般都会选INNER，即带了ON条件。**外连接必须有ON语句**。一开始我经常把ON语句误写作WHERE，看其他人的代码，也发现这种错误，说明这对SQL掌握不深的人来说，可能是普遍现象，详细剖析下这两个关键字的语义区别。

从简单的单表查询可知，WHERE是对结果表做过滤的谓词。JOIN动作是针对两张表的笛卡尔积，为了满足只取特定的JOIN结果，引入了ON谓词，专门用于多表JOIN过程中的判定，所以虽然WHERE和ON后面都可以跟比较语句，但两者的作用阶段是不同的。如果不用ON，只用WHERE最终也能得到正确结果，但是理论上一定会带来性能的额外开销：前面提到WHERE是针对单张表，意味着JOIN必须生成所有的结果集，得到这个结果集后，才能做WHERE过滤，这就会导致中间结果集过大，而ON恰恰能解决生成结果表过程匹配的问题。另外前面提到了优化器会把WHERE动作前置，但是并不会把WHERE条件作用于JOIN的过程中，所以说ON是JOIN的伴生动作，而WHERE是完全独立的另一个阶段，这两个阶段的顺序可以调换，但绝不会融合。

连接首先分交叉连接和外连接，两者结果的约束是很大的。交叉连接的结果数是两张表的积，而外连接则是以一张表为准。

外连接细分了LEFT、RIGHT、FULL这3种连接，LEFT OUTER JOIN可以简写成LEFT JOIN。左右只是方向不同，只需要实现一种就可以。左连接后面的限定条件*可能不生效*，结果既包含符合满足限定的连接行，也包含不满足限定的左(或右)行，这些不满足限定的行会由NULL来填充。这正是NULL必须存在的理论依据。所以即使表定义的某列规定了NOT NULL，但在连接结果还是会出现NULL，无法避免。两张表的LEFT JOIN的意义不太明显，如果有多张表会更好理解。

考虑学生选课场景，学生和课之间是多对多的关系，表s记录了学号和学生的详细信息，表c记录了课程信息，表sc记录了学号和课程号的关联，如果要还原出学生姓名和课程名字，用这句

```
select s.Name,C.Cname from student_course as sc left join student as s on s.Sno=sc.Sno left join course as c on c.Cno=sc.Cno
```

在计算过程中，用sc表作为左连接的左表，先替换学生信息并保持住课程的信息(暂时还无意义)，等第二次左连接的时候，用课程信息替换掉上一次左连接的内容，最终的select结果中不保存sc的任何内容。

## JOIN的实现算法

有单机和分布式，但是单机是基础，如下3种

1. Nest Loop Join: 最简单但性能也最低，拿左表的每一行，从右表循环匹配，复杂度O(MxN)。过程中可以利用右表的索引来加速。
2. Sort Merge Join: 将两张表分别进行排序，然后再扫描的时候，因为顺序已经固定，所以就不需要做全表扫描，因此连接的复杂度是O(M+N)。不过考虑到对两张表排序的成本, 不能过分乐观。
3. Hash Join: 将小表的joinkey和关联内容提取出来，对joinkey列做hash，得到中间表保在在内存，对大表做scan并按同样的hash去内存中找到匹配记录

对于常见的等值连接来说，如果小表的内容足够小，都会采用Hash的方式。要注意的是，这个足够小，并不是仅指joinkey，而是要把关联的内容一起算上看总大小。

Nest Loop尽管复杂度高，但在不等值连接的时候一般都用这种方式，因为Sort Merge要求表必须做排序，而排序的成本不低，所以权横后还是会选择用的Nest Loop。

分布式场景怎么又增加了shuffle和broadcast这两种策略，和单机版组合理论上一共有6种策略。但是spark放弃了broadcost和sort merge组合，比hash性能不足，能力上又不如NestLoop，因此最终就只有5种策略。

## semi和anti

这两种都是从子查询优化中演化出来的，也间接说明原生几种join的表达力不足。

left semi join表示半的语义，具体有这几条

1. 只能select左表数据，这也是semi最核心的含义
2. 结果不会受右表关联重复数据的影响，从第一点可以看出，右表只是用于关联，不参与结果构建，也就不会导致重复
3. 必须搭配left/right其中一种，不能单独semi，否则无法确定取哪一半

anti表示的反，等效与先left再取右边为null，但写起来方便。可以left anti join，也可以直接t1 anti join t2取t1有而t2没有的数据。

这两种更像子查询优化而不是独立语义，所以没在标准中找到，但部分实现会支持。