# 多进程与进程间通信

在linux中，fork和vfork的系统调用都是clone，当然标记是不同。

* fork: CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD
* vfork: CLONE_VM|CLONE_VFORK
* pthread_create: CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID

以目前的性能优化而言，两者的开销区别并不大，更大的区别在于执行流程和内存空间不同。fork执行后，父子进程一定会被执行到，规范没有规定执行顺序，一般都是同时开始调度。而vfork则一定是子进程先执行，而且**如果子进程没有调用\_exit（不是exit）或exec函数的话，父进程不会被执行**。

fork是COW，而vfork的子进程可以修改父进程的变量（纯share，没有copy），这也是为什么父进程必须等待子进程调用\_exit后才会被执行的原因。

用strace观察锁，绝大多数都是futex函数调用，且操作都是FUTEX_WAIT_PRIVATE，很难看出区别，只有一次触发了FUTEX_WAIT。看资料说现在的锁实现，大多是先自旋一定次数，如果还获取不到，再用户态等待，不会轻易进入内核态，毕竟futex的目的就是防止程序进入内核态。子线程结束调用exit，而主线程结束调用exit_group。

创建线程的身份是tid，但由于操作系统的进程API在前，所以同一个主线程，不管创建多少子线程，这些子线程的pid都一样。

## 僵尸状态

为什么会有这个状态呢？我能想到的惟一原因是父进程要取得子进程的退出状态等信息。僵尸状态是每一个进程退出前的必经过程（只有init进程例外，因为不会退出）。僵尸态只记录一个整型状态，但不止一种信息，用wait.h的特殊宏可以解析出是exit还是stop，收到的信号量等等，而且处在僵尸态的进程，/proc/<pid>/目录的文件会的owner会变成root。但僵尸进程毕竟占用内核的pid资源，所以必须回收。

结束僵尸态有几种方法

1. 父进程调用wait()
2. 父进程显式忽略SIGCHLD信号，必须用SIG_IGN才能自动结束僵尸，其它注册函数没用

另外好像用llvm编译的程序，虽然没有注册SIGCHLD，也不调用wait，子进程仍能结束不会变成僵尸。

## 进程会话和作业

多个进程间会进行分组，有几种分组方式。

* session: 一般指shell session，一次登录sh导致的所有进程都在这个session下，而sh进程就称为session的领头进程，通过ps的SID列可以查到
* job: 最典型用管道符串起来的多个进程，称为一次job。第一个进程是job的领头进程，通过ps的PGID列可以查到

## 7种进程间通信机制

1. pipe 管道，最简单，对应syscall有pipe和pipe2两种，pipe2多支持几种选项，是linux在2.6.27才加入的接口
2. fifo 有名管道，对应syscall是mknodat，因为有名，且对应磁盘上的文件，因此用mknod方式创建。
3. mmap 文件映射共享IO，速度最快（原理：在内存开辟一片缓冲区，把文件映射到内存上，你直接去操作内存就可以了）。shell中的管道符用的就是这种，但不管输入端的内容有多大，都只调用两次mmap（必须有MAP_SHARED标记），大小都是128K。
4. 本地socket 最稳定
5. 信号 携带信息量最小的
6. 共享内存 开辟一块内存区域，大家都能访问，一个进程退出之后，这块内存还会给你保留下来，后来者还可以继续使用
7. 消息队列

以上部分方式可以用ipcs查看

## 匿名管道

先从匿名管道说起，在shell中执行 `ls | grep xx` 时，背后的流程是当前的sh为父进程，fork出两个子进程，分别exec执行ls和grep，而且这两个子进程之间会有匿名管道pipe()连接起来。由于两个子进程的父进程都是shell，因此存在亲缘关系，匿名管道以fd方式存在，通过fork方式被两个子进程共享，这就是匿名管道可以工作的原因。

python多进程使用pipe2匿名管道，数据pickle化后传输。

顺便说一句，读管道要用read语句，而读命令行输入则是$#一系，由于输入形式的不同，处理逻辑也不同。

## 有名管道

用读方式打开有名管道，默认是BLOCK模式，意味着当没有进程写入时，会一直堵塞。而一旦有数据写入，会源源不断地读到数据，即使没有数据写入，也不会阻塞读动作。因此对有名管道的读，每次读到空，就要关闭管道，并再次尝试打开，否则CPU会急剧升高。形如以下

```
while true {
    fd = open('fifo', 'r')
    line = fd.read()
    fd.close()
}
```

观察这两种管道的使用，会发现都使用`pipe_wait`系统调用，因此都叫管道。

匿名管道因为使用形式的关系，数据流动是单向的。而有名管道形式上是文件，当然是双向，打开用读写方式。而且有名管道涉及进程间交互，往往是双向流动。如果A到B，B直接打印到终端，人眼看上去没有区别，程序是无法捕获这段打印，有点类似内核输出报警，你能看到却没有任何方式拦截并重定向它。

引申一点，shell脚本中怎么判断是命令行启动，还是接在管道后？这两种情况下，stdin没有区分，这时就要再往前想一步，stdin这个逻辑概念指向谁？匿名管道模式，stdin指向的显然是管道，而命令行模式下，stdin指向的是终端，真实的终端叫tty，后来网络化后叫pts，但只是表示不同，终究有个对应的实体。tty命令就是打印stdin所对应的终端，如果stdin对应的是匿名管道，则会返回错误并提示`not a tty`。除了tty，用`[ -t 0 ]`也能判断0是否为tty。对应的C函数是isatty。

## 文件锁

文件锁用flock保证一个进程启动时独占