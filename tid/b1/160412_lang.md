# C++模板引起的一个二进制兼容问题

问题来源是这样的，公司的基础库里，用于实现Observer模式的Signal库是模板写的。模板嘛实现代码都在.h头文件里，在之前的一个版本里，因为要解决一个bug，对Signal模板类增加了两个成员变量，在提交时内部几个人评审，都觉得模板既然是在各自的cpp内实例化，且不涉及对象的传递，即使改变了类大小，也不会引起问题。然而最终集成的时候，就是挂在Signal类里。

一度我以为是应用的使用者在两个不同的库之间（这两个库编译时引用不同版本的头文件），传递了Signal的实例引起，但后来经同事提醒，加上回忆起之前做的一个实验，发现确实是增加类变量引起的不兼容问题。原因如下：

模板类在编译时，的确是在每个编译单元即cpp生成的.o中实例化出来的，但是这个实例化出来的函数（或类）的链接属性是Weak。通过readelf -s命令可以查看。正常如果不是手写attribute((weak))属性，编译出的要么是Global要么是Local。由于是Weak属性，如果实例化时的参数类型一样，生成的函数名也一样，而在不同模块生成的.o中的模板代码尽管不同，但因为名字相同，在最终的链接环节，会因为Weak的原因随机挑一个进入最终的可执行程序。而挑选哪一个是由链接器决定的，无法预测。因此当A库用了size更大的模板类，而B库用了原始版本，链接时如果恰巧选择了A库实例化的Signal类最终进入可执行程序，则会破坏B库中紧跟在Signal类后的变量。反过来，如果链接时选择了B的类进入可执行程序，则A在执行时还是用的原始库，不会破坏数据，但修改Signal的bug的期望也落空了。

怎么在A、B库不同步更新头文件的情况下，解决这个问题呢？目前能想到的只是保证不崩溃，但做不到百分百修复bug。方法就是模板类也用pImpl方式实现，即模板类的成员变量仅使用一个void* internal指针，具体的数据在这个指针所指向的堆上扩展。这样不论链接器选择哪个版本的模板类，大小始终是一样的。如果用的不是模板类，也一样要遵守这个原则，只是非模板类因为是Global，所以可以控制最终链接进的版本，而使用模板就没这么幸运了。换句话说，如果要用C++的类作为接口，不论是普通类或模板类，为了扩展并保证二进制兼容，一定要遵守pImpl守则。