# Lisp与Haskel比较

这两门语言从不同的角度去解决了一个共同的问题：如何减少重复代码，如何提高抽象。

首先两门语言都是建立在lamdba演算之上，都提供了first class的函数支持，所以在这两门语言里函数都是构建计算的基本单元，而不是c系语言的statement。

但是即使是书写函数，人们依然希望获得更加高级的抽象，来减少重复，举几个具体的例子：

解析文本这个过程，前进buffer >> 判断是否符合当前的语法结构 >> 失败了？报错 >> 成功了继续重复（重复的代码：判断）
渲染模版的过程，计算一个模版片段 >> 计算下一个模版片段 >> 把模版片段相连 >> 继续重复 （重复的代码：相连）
设计一个状态机的过程，拿到上一个计算之后的状态值 >> 基于这个值运行状态机，产生新的状态和可能的计算结果 >> 继续重复 （重复的过程：状态传递）
我们看到这个时候依赖人工书写这些代码会出现大量重复的情况，LISP的思路基于语法结构，LISP巧妙的利用lamdba的基本书写形式 (lamapp variables)，构建了模版(marco)，这意味着只要是一段代码具有相同的语法结构，比如重复地进行判断，你都可以把它抽象为模版，由编译器或者解释器来替你做语法层面的替换，自动生产重复的代码。需要注意的是LISP的模版抽象是基于语法树(AST)而不是字符串的，同时LISP的AST非常简单，这意味着书写构建AST的模版也非常简单。


而Haskell的思路是建立在类型类多态的基础上的，haskell里构建大规模计算的类型类是Monad，它定义了一个多态的连接函数bind，aka. >>= 。 这个函数的作用是连接上下两段相同类型的运算。在这个连接的过程中，你可以通过定义判断，或者相连，或者传递状态等等，来实现不同的计算语义，这个类型类是haskell减少代码重复的关键。而这个构建计算的框架和haskell的强类型系统非常契合。


当然LISP也可以实现一个untyped的monad模版，haskell也支持template haskell，所以在LISP里monad这是众多模版中的一个，而在Haskell中，LISP的AST也只是众多语法结构里比较底层的一个。但是这些并不意味着谁比谁更加强大，这只是两个语言解决问题的思路不同。


所以无论如何，如果可以，请把这两门语言都认真的学习一番，即使你可能不在实践中使用它们，它们都会给你带去很不一样的编程思路。
