# 学elixir

## 设计哲学

支持脚本方式运行（elixir xx.exs），但它的理念是工程化的、有极强文件组织要求的语言，所以不要以脚本语言的方式使用。

每个文件必须显示定义defmodule，最终也会被编译为同名beam文件，这个特性决定了elixir对结构和命名非常看重。

## 构建工具mix

### 初始配置

除了构建，往往还依赖hex和rebar3，建议第一时间安装。

* `mix hex.config mirror_url https://hexpm.upyun.com`
* `mix hex.config unsafe_https true`

### 项目结构

mix new abc 创建的项目(库)结构很工整

* mix.exs: 不会编译为beam，但仍是defmodule，3个函数管理配置。def project-项目定义; def application-项目类型lib/sup; defp deps-依赖。通过iex -S mix运行默认构建指令
* lib/ 工程源码，对应其它语言的src/，但用了更符合erlang习惯的名字lib，也体现了*项目即库*的理由。在erlang语境里，src多用于临时或工具生成代码
* test/ 测试
* deps/ 下载的依赖库
* _build/ 执行mix compile/test/release之后自动创建，存储构建产物

mix.exs依赖操作符`~>`又叫 "twiddle-wakka" 或 "approximately greater than" 表示大致大于,非常精确

```
defp deps do
    [
      {:plug, "~> 1.15.3"},
      {:plug_cowboy, "~> 1.0"}
    ]
end
```

建议OTP方式打包产生app文件（erlang格式纯文本），以Application为单位运行，入口start/2函数。

```
defmodule Xyz.Application
use Application  # 表示是 OTP 应用
def start
```

## 基础知识

* 原子类型(符号) :foo,冒号在前

常用容器类型表示法和其它语言非常不同

* `[]`单向链表: 默认不能下标操作，在函数式语境下，下标本身就很少用。占了这么常用的符号，是因为`[]`在模式匹配极为常用，而且保持和erlang一致性
* `{}`元组:（固定长度数组，和py的tuple同）
* `%{}`map: `%{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}` 容易混淆的点 foo: 和 :foo =>等价。冒号在后面，是原子加上映射符的语法糖。由于和原子有关系，所以仍然用冒号，但放在后面

## 模块和导入

模块和文件名不一样但有映射关系：模块名必须大写，文件名则小写，这是erlang的约定。import MyLib对应my_lib.ex。因为elixir区分函数和宏，导入机制和其他语言相比要复杂得多

* import: 慎用。类似`import *`隐式导入全部函数/宏符号，非常异类
* use/require: 引入宏，use xx等价于`require xx;xx.__using__()`
* alias: 不算引入，只是简化变量写法

## 安装 phoeix 框架 - 依赖 pg,太重

安装 hex 模块`mix local.hex`,但似乎网络受限,提示下载 ez 包后离线安装,其实 ez 就是 zip 包,安装后会在~/.mix 目录下解压若干个编译后的 beam 文件.rebar 也要手动装
