# 学elixir

## 设计哲学

支持脚本方式运行（elixir xx.exs），但它的理念是工程化的、有极强文件组织要求的语言，所以不要以脚本语言的理念去学习。

每个文件必须显示定义defmodule，最终也会被编译为同名beam文件，这个特性决定了elixir对结构和命名非常看重。模块和文件名不一样但有映射关系：模块名必须大写，文件名则小写，这是erlang的约定。比如import MyLib对应my_lib.ex。

## 工具mix

### 项目结构

mix new abc 创建的项目(库)结构很工整

* mix.exs: 解释执行不会编译为beam，但必须是defmodule(名字可任意修改)，但必须有`use Mix.Project`。通过`def project`符合behaviour，除此之外还会有两个约定俗成的函数: def application-项目类型lib/sup; defp deps-依赖。通过iex -S mix运行默认构建指令
* lib/ 工程源码，对应其它语言的src/，但用了更符合erlang习惯的名字lib，也体现了*项目即库*的理由。在erlang语境里，src多用于临时或工具生成代码。其实lib这个名字也可以自定义，通过在mix.exs定义 `elixirc_paths` 修改
* test/ 测试
* deps/ 下载的依赖库
* _build/ 执行mix compile/test/release之后自动创建，存储构建产物

项目有library和application两大类，如果在def application定义了`mod:`属性，相当于规定了主函数入口，也就成为了app。如果没有`mod:`就是库。和C语言的精神一致，但入口函数的名字定义可以更灵活。

mix.exs依赖操作符`~>`又叫 "twiddle-wakka" 或 "approximately greater than" 表示大致大于,非常精确

```
defp deps do
    [
      {:plug, "~> 1.15.3"},
      {:plug_cowboy, "~> 1.0"}
    ]
end
```

建议OTP方式打包产生app文件（erlang格式纯文本），以Application为单位运行，入口start/2函数。

```
defmodule Xyz.Application
use Application  # 表示是 OTP 应用
def start
```

### 其他工具依赖

除了构建，还依赖hex和rebar3，建议第一时间安装。

* `mix hex.config mirror_url https://hexpm.upyun.com`
* `mix hex.config unsafe_https true`

hex最初是为erlang设计，后来elixir也复用这套系统，所以有单独的目录`~/.hex`，文件也采用.config后缀，并且内容格式也遵照erlang语法

## 语法基础

* 原子类型(符号) :foo,冒号在前
* `[]` 单向链表: 不能下标操作，在函数式语境下，下标本身就很少用。占了这么常用的符号，是因为`[]`在模式匹配极为常用，而且保持和erlang一致性
* `{}` 元组:（固定长度数组，和py的tuple同），可以下标索引
* `%{}` map: `%{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}` 其中 `foo:` 和 `:foo =>` 等价。冒号在后面，是原子加上映射符的语法糖。由于和原子有关系，所以仍然用冒号，但放在后面
* `[a: 1, b: 2]` Keyword List: 完整的写法`[{:a, 1}, {:b, 2}]`，非常有用，甚至为这个结构特意设计了语法糖。并且作为函数最后一个参数时，连外侧的方括号都能省略，足见偏爱之深

## 模块和导入

比起很多语言一个关键字包打天下，elixir的设计要优雅和严谨得多，又因为区分函数和宏，导入机制和其他语言相比要复杂

* alias: 严格说不算引入，只是将全路径的module简化到最后一级，方便看到module名时能溯源
* require/use: 引入宏的必须步骤，use xx等价于`require xx;xx.__using__()`
* import: 将函数和宏复制到当前空间，隐式导入全部函数/宏(前提是已经require)，类似`import *`，一般建议加`only:`或`except:`约束

## 继承OTP

没有library概念，每个项目都叫app，app之间可以互相调用，每个app可以通过mod:指定运行入口。由于Erlang虚拟机的存在，多个app都在运行是很自然的事情

## 安装 phoeix 框架 - 依赖 pg,太重

安装 hex 模块`mix local.hex`,但似乎网络受限,提示下载 ez 包后离线安装,其实 ez 就是 zip 包,安装后会在~/.mix 目录下解压若干个编译后的 beam 文件.rebar 也要手动装
