# 22 两个小微JS库的使用

因为网站重构，想使用htmx库，奈何不适应只得重新用JS，但不想用太复杂的库遂选了两个，一个MVVM一个类jQuery库，记录一些JS的惯用法。

## psQuery

说说$变量的构造，在库的开始定义一个单变量的函数，在函数定义完成后惯例性的调用，此时传入this参数（对应window）。然后在代码中用了句`n.$||(n.$=t)`。这个n就是this，t则是构建好的类jQuery对象，先判断全局是否已经定义$变量，没有就把自己挂接上去。

最终还是借助GPT的帮助，用XMLHttpRequest实现自己的功能。无非就是构建XHR对象，并用open/set方法设置是否异步和参数，最后通过send真正触发动作。

## DB.js

MVVM库，希望监听的DOM元素增加类似`db="text:spanText,class:red"`属性。当你手动执行DB.scanHTML后，会扫描document所有节点，如果有db属性就会用DB.observable转化成可监听对象，然后把db属性去掉。接下来操作js对象就能自动触发DOM元素的变化。只要保证js的对象名，和db属性某个冒号后的名字一样，就能绑定。

单纯的绑定没大价值，有意义的是compute属性，实现了一个元素依赖其它元素的自动更新。依然借鉴思路，实现了一个简化DOM元素访问函数。

## MVVM

要使用双向绑定，要遵循以下几点

1. 数据(json) must: **el&data** may: *fn* (which used to init Vue)
2. 视图(html) 被div包裹的若干元素，顶层div的id对应`el`
  - 输入元素(input)有"v-model" attribute，值指向data的某个字段
  - 显示元素(p/h1)的内容，使用`{{xx}}`或`_2{{xx}}`指向data的某个字段就实现了绑定，甚至能执行fn的自定义函数

实现双向绑定，基于两个核心原生函数：addEventListener和defineProperty

Vue持有Observer(即.\$data，Compile会把v-model绑定到.\$data，于是修改带有v-model的input会触发set。set的定义调用Dep.notify，因为Dep持有Watcher数组，于是遍历并调用Watcher.update。update会比较新旧值，不同再触发CompileUtil.model中定义的函数
Vue还会创建Compile，给DOM添加event，并绑定值，值变化了触发形成闭环

构造阶段，Observer必须在Compile前。原因：Observer会对.\$data做defineProperty(addSub)，v-model(nodeType=1)和{{}}表示(nodeType=3)都会触发addSub。在此基础上，compile的new Watcher才会触发.\$data的get魔法，实现双向绑定闭环。
如果compile在前，不能触发addSub，导致notify时没有对象。Compile利用了createDocumentFragment来加速DOM渲染

使用MVVM，除了改Model值（比如ajax），还有一种是Input DOM->Model->Display DOM。通过Input DOM的addEventListener的回调，修改Model，进而触发defineProperty时set的notify，然后修改了Display DOM的textContent。defineProperty的get有个小技巧，只有在编译时（第一次）会触发addSub；其他时候简单地返回值

扩展

原版只能实现值透传，我加了fn元素扩展，在DOM里用`_1`这样的仿匿名函数，实现自定义函数逻辑

![MVVM](/img/mvvm.png)

小技巧

1. 值引用支持多级点指定(其实是通过reduce实现)
2. 用textContent而不是innerHTML，因为textContent不做解析，速度快且安全

## 再次尝试htmx by 24.09.21

超文本hypermedia刚兴起的时候，跳转只有anchor和form两种形态。随着JS大行其道，传统的方式显然跟上主流，但htmx想复兴这套理念，虽然底座当然是js，但使用上更回归html，当然需要开发理念也要转变。

htmx是基于html的语义，htmx的核心将AJAX的参数，拆成多个属性然后嵌到元素里，返回内容直接替换目标DOM，因此返回格式必须是DOM而不能是JSON。如果前端有if逻辑，htmx无法实现，需要在前端实现分支

使用参数的3种形式

* form: 最基础的方式，内部所有input类元素会自动带上，参数名取决于input元素的*name*属性，不是id属性。如果input元素没有*name*，则这个元素对于htmx的请求就是无用的。这条也好解释，因为协议要求参数必须有名字，所以要符合规范当然要有name属性
* hx-include: 可以自由选择参数，但只有post时支持写多个hx-include；如果是get请求，只有第一个hx-include生效。同样的，元素必须有*name*
* hx-vals: 是个JSON字典，必须有key，所以不能是数据。可以是字面量，也可以写成'js:{"ver":htmx.version}'。html的属性大多数时候用双引号，同时支持内容本身有双引号时，用单引号作为定界符。这样就能和JSON双引号格式很好地配合

hx-include（复数个）和hx-vals可以联用，只是get请求只有第一个hx-include和hx-vals生效；post请求则全部生效。

对结果的替换用hx-swap进行修正，可以插到目标元素之外（beforebegin/afterend），也可以插入目标之内（afterbegin/beforeend）。
