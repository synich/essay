# continuation的理解

Scheme 和SmallTalk并不采用堆栈来保存上下文，而是将这些信息保存在continuation记录中。这些continuation记录和堆栈的Frame的区别在于，它不采用后入先出的线性方式，所有continuation记录被组成一棵树（或者图），从一个函数调用另一个函数就等于给当前节点生成一个子节点，然后把系统寄存器移动到这个子节点。一个函数的退出等于从当前节点退回到父节点。这些节点的空间回收是由垃圾回收器(garbage collection)来管理。如果没有引用这个continuation记录，则它就是可以被删除的。这样的调用方式和堆栈方式相比，它可以在一个函数内的任何位置储存自己的上下文信息，然后，在以后某个适当的时刻，从其它的任何一个函数里面返回到自己现在的位置。

由于每次延续被恢复的位置不同，可以理解为函数拥有了多个不同的入口点，从这个角度可以和协程一起理解。 [[协程剖析]]

Python的yield教程都说是生成器，思考其实质，函数的上下文被保护，从而可以被多次调用，精神层面和continuation是一脉相承，而且加入了send和throw函数，也更方便易用。

lua表面上只有协程，但其实和continuation是相通的。[[Lua的Continuation]]