# TCP的状态

TCP的状态多达11个，4个连接7个关闭。之所以会这么复杂，是因为TCP作为双向全双工协议，读写端是完全独立的，建立连接的过程不区分，所以相对简洁一些，一旦连接建立后，分化出读写两个管道，要关闭这两个独立的管道，会经历不同的状态，显然复杂度会翻倍。调用close()只能主动关闭写管道，读端会被动一些。

| 写关闭状态 | 说明 | 读关闭状态 | 说明 |
| --- | --- | --- | --- |
| FIN_WAIT1 | 发送FIN给对端，关闭写道道 | CLOSE_WAIT | 收到FIN，关闭读通道 |
| FIN_WAIT2 | 收到对方的ACK，但还没收到对方的FIN | LAST_ACK | 读端Only，收到FIN后自动触发close进入该状态，并等待ACK，网络中断时才会出现 |
| TIME_WAIT | 收到对方的FIN | | |

还有两个状态是读写端都会有

* CLOSING  本该收到对端ACK却收到FIN，发ACK给对方，就会进入最终的CLOSED
* CLOSED  收到FIN后再过2个MSL才可以彻底关闭
