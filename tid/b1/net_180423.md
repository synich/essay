# TCP的状态

TCP的状态有11个，4个连接7个关闭。之所以这么复杂，是因为TCP作为双向全双工协议，读写端完全独立，建立连接的过程不区分，所以相对简洁一些，一旦连接建立后，分化出读写两个管道，要关闭这两个独立的管道，会经历不同的状态，显然复杂度会翻倍。调用close()只能主动关闭写管道，读端会被动一些。

## 连接

| 状态 | 说明 | 状态 | 说明 |
| --- | --- | --- | --- |
|LISTEN|正在侦听连接请求 |ESTABLISHED|已打开的连接|
|SYN-SENT|发送连接请求后，等待匹配的连接请求（客户端） |SYN-RECEIVED|收到并发送连接请求后，等待对方确认（服务器）|

## 关闭

| 写关闭状态 | 说明 | 读关闭状态 | 说明 |
| --- | --- | --- | --- |
| FIN_WAIT1 | 发送FIN给对端，关闭写道道 | CLOSE_WAIT | 收到FIN，关闭读通道 |
| FIN_WAIT2 | 收到对方的ACK，但还没收到对方的FIN | LAST_ACK | 读端Only，收到FIN后自动触发close进入该状态，并等待ACK，网络中断时才会出现 |
| TIME_WAIT | 收到对方的FIN | | |

还有两个状态是读写端都会有

| 读写关闭共有状态 | 说明 |
| --- | --- |
| CLOSING | 本该收到对端ACK却收到FIN，发ACK给对方，就会进入最终的CLOSED |
| CLOSED | 收到FIN后再过2个MSL才可以彻底关闭 |
