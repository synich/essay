# 多线程的锁和终止

## 锁

自旋锁（spinlock）很好理解。对自旋锁加锁的操作，你可以认为是类似这样的：

```
while (抢锁(lock) == 没抢到) {
}
```
只要没有锁上，就不断重试。显然，如果别的线程长期持有该锁，那么你这个线程就一直在 while while while 地检查是否能够加锁，浪费 CPU 做无用功。

仔细想想，其实没有必要一直去尝试加锁，因为只要锁的持有状态没有改变，加锁操作就肯定是失败的。所以，抢锁失败后只要锁的持有状态一直没有改变，那就让出 CPU 给别的线程先执行好了。这就是互斥器（mutex）也就是题目里的互斥锁（不过个人觉得既然英语里本来就不带 lock，就不要称作锁了吧）。对互斥器加锁的操作你可以认为是类似这样的：

```
while (抢锁(lock) == 没抢到) {
    本线程先去睡了请在这把锁的状态发生改变时再唤醒(lock);
}
```

操作系统负责线程调度，为了实现「锁的状态发生改变时再唤醒」就需要把锁也交给操作系统管理。所以互斥器的加锁操作通常都需要涉及到上下文切换，操作花销也就会比自旋锁要大。

以上两者的作用是加锁互斥，保证能够排它地访问被锁保护的资源。

不过并不是所有场景下我们都希望能够独占某个资源，很快你可能就会不得不写出这样的代码：

// 这是「生产者消费者问题」中的消费者的部分逻辑
// 等待队列非空，再从队列中取走元素进行处理

加锁(lock);  // lock 保护对 queue 的操作
```
while (queue.isEmpty()) {  // 队列为空时等待
    解锁(lock);
    // 这里让出锁，让生产者有机会往 queue 里安放数据
    加锁(lock);
}
data = queue.pop();  // 至此肯定非空，所以能对资源进行操作
解锁(lock);
消费(data);  // 在临界区外做其它处理
```

你看那个 while，这不就是自己又搞了一个自旋锁么？区别在于这次你不是在 while 一个抽象资源是否可用，而是在 while 某个被锁保护的具体的条件是否达成。

有了前面自旋锁、互斥器的经验就不难想到：「只要条件没有发生改变，while 里就没有必要再去加锁、判断、条件不成立、解锁，完全可以让出 CPU 给别的线程」。不过由于「条件是否达成」属于业务逻辑，操作系统没法管理，需要让能够作出这一改变的代码来手动「通知」，比如上面的例子里就需要在生产者往 queue 里 push 后「通知」!queue.isEmpty() 成立。

也就是说，我们希望把上面例子中的 while 循环变成这样：

```
while (queue.isEmpty()) {
    解锁后等待通知唤醒再加锁(用来收发通知的东西, lock);
}
```

生产者只需在往 queue 中 push 数据后这样，就可以完成协作：

触发通知(用来收发通知的东西)，一般有两种方式

* 通知所有在等待的（notifyAll / broadcast）
* 通知一个在等待的（notifyOne / signal）

这就是条件变量（condition variable），也就是问题里的条件锁。它解决的问题不是「互斥」，而是「等待」。

至于读写锁（readers-writer lock），看英文可以顾名思义，在执行加锁操作时需要额外表明读写意图，复数读者之间并不互斥，而写者则要求与任何人互斥。读写锁不需要特殊支持就可以直接用之前提到的几个东西实现，比如可以直接用两个 spinlock 或者两个 mutex 实现：

```
void 以读者身份加锁(rwlock) {
    加锁(rwlock.保护当前读者数量的锁);
    rwlock.当前读者数量 += 1;
    if (rwlock.当前读者数量 == 1) {
        加锁(rwlock.保护写操作的锁);
    }
    解锁(rwlock.保护当前读者数量的锁);
}

void 以读者身份解锁(rwlock) {
    加锁(rwlock.保护当前读者数量的锁);
    rwlock.当前读者数量 -= 1;
    if (rwlock.当前读者数量 == 0) {
        解锁(rwlock.保护写操作的锁);
    }
    解锁(rwlock.保护当前读者数量的锁);
}

void 以写者身份加锁(rwlock) {
    加锁(rwlock.保护写操作的锁);
}

void 以写者身份解锁(rwlock) {
    解锁(rwlock.保护写操作的锁);
}
```

如果整个场景中只有一个读者、一个写者，那么其实可以等价于直接使用互斥器。不过由于读写锁需要额外记录读者数量，花销要大一点。

你可以认为读写锁是针对某种特定情景的「优化」。但个人还是建议忘掉读写锁，直接用互斥器。

### 补充

spinlock 不涉及操作系统，就是等价于 while 的俩汇编指令。mutex 虽然经典实现会引起 context switch，但是现在的具体实现不一定，比如 Linux 下可以利用[[用户态锁]]的 futex。回答里的那个「本线程先去睡了请在这把锁的状态发生改变时再唤醒」不涉及条件变量，可以认为是个系统调用。

读写锁内部是至少需要用一把锁来保护当前读写数，如果你的临界区很小，读写锁相比一般的锁并不能带来很大的优势，甚至可能性能更低。

另一方面，读写锁要真正发挥效能，条件也比较麻烦。比如实际的读写锁通常不用例子里两把锁的实现，而是用一把锁、一个条件变量来实现，好处是可以缓解写者饥饿的情况（一旦有写者在等锁，后续读者都需要等写者离开后才能继续），但这样一来，如果读者的临界区没有明显小于写者的临界区，阻塞情况可能会变得比较不理想

不是说不要用读写锁，而是读写锁往往没有看上去那么理想。个人建议是可以优先用 mutex，如果遇到瓶颈后可以选择替换为读写锁，看看能否带来性能提升。

通常是用信号量（semaphore）来实现锁，而不是用锁来实现信号量。至于如何保证线程安全，可以理解为有专门的机器指令来保证原子操作。

* 请教一下，为什么"以读者身份加锁"那里，加写锁的条件为什么是"rwlock.当前读者数量 == 1"？

第一个到达的读者负责抢写锁，确保写者等待；最后一个离开的读者负责归还。如果你把把所有读者看成一个整体的写者，可能更方便理解为什么这么抢。

一个进程获得锁资源进入临界区后，很可能在锁没有释放前被调度走，而其他进程在等待锁资源，这样就会发生死锁。我知道通常spinlock会关中断，所以用spinlock锁定后进程不会被调度走。那么其他几种锁会允许获得锁后被调度吗？

如果我的理解没错的话，你说得这种情况是正常情况，还是可以调度回来的，不是死锁。如果是两把及以上的锁，各个线程上锁顺序不一致，才会出现你说的死锁问题。

* 请教下 前两个例子： 我感觉自旋锁和互斥锁都会引起上下文切换，假设一个单核cpu 分配时间片给多个线程竞争相同自旋锁，其中只有一个拿到锁，然后时间片结束切换到其他线程但它还持有锁，那么其他线程获得cpu 分片但没获得锁进入自旋，cpu 分片结束还是会引起上下文切换，这样跟互斥锁的主动上下文切换似乎是一样的。那它自旋的意义何在呢？因为从这里看起来你进入自旋一定获取不了锁。

单核「进入自旋一定获取不了锁」是不对的，因为还会被操作系统切换回来，只不过是浪费时间片。自旋锁本意是给多核/处理器场景用的，除了你举的例子里浪费时间片的问题，如果是在单核非抢占式上用经典自旋锁，那么铁定死锁。多核/处理器的场景下，自旋锁的意义在于优化一些短时间的锁（比如一些自旋等待的时间几乎始终会比互斥锁让线程睡眠&唤醒操作的时间要短的情况）。现代操作系统在实现自旋锁、互斥锁时，一般都会做优化，比如可能会让互斥锁先自旋一小会儿；可能会在自旋锁自旋超过一定时间后强制切换上下文；也可能会在单核非抢占式上让自旋锁什么都不干……不过这些「优化」我们编程时通常都不需要了解，按照经典实现去理解就足够了。

* 您好，问一个问题， mutex 的lock后，unlock应该是要同一个线程才能执行的，但像上面的读写锁， 解锁（rwlock.保护写操作的锁） 的时候不一定是加锁的那个线程怎么办啊

如果你真的想要用两个 mutex 实现的话，需要看你用的 mutex 接口的具体情况，比如 C++17 的 std::shared_mutex 是支持不同线程解锁的。当然你也可以把 mutex 换成 semaphore。

## 终止

多线程不能随意终止，否则就违背了计算可预测性。POSIX引入了协作式取消和取消点的概念，即使这样`pthread_cancel`仍然要配合cleanup函数才能保证fd释放，否则长期运行可能导致fd不足。

bits/sigthread.h（包在signal.h里）定义了`pthread_kill`，但这个已经不属于线程函数的范围了。