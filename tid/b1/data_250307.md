# 夏令时与数仓设计

夏令时起源于一战时欧洲的德国和奥地利，在4月某一天开始将钟表人为调快（往前）调一个小时，但不改变上下班的时间。利用人类的错觉，早上仍然8点上班，此时太阳已经足够亮；下午6点下班，但实际才下午5点，此时太阳还很明亮，人类就可以多在户外活动一个小时，实现节约能源的目的。传说在当时确实起到了效果，但我觉得这种方式非常愚蠢，相比之下我们国家的冬夏令时上班时间不同，很优雅。

对应到数仓设计领域，如何分区成了最大的难题，有两种选择

1. 一天对应人们口中的一天，这种方式会在一年中产生两天比较特殊的分区，11月1号存放了25小时的数据（fall back），4月那1天只有23小时（spring forward）
2. 不考虑夏令时的偏移，每一天都是固定的24小时

咨询了云存储和云数据库，他们由于历史兼容性等原因，选择每天固定24小时，然后在查询的时候进行夏令时偏移。回到数仓设计领域，我开始也想采用固定24小时方案，但是在统计计算上会很困难，每次要读两个分区的数据才能计算人们口中的一天。毕竟夏令时还是要参考国外的人是怎么理解，问了GPT o3mini，回复是两种方案都有，但是考虑到人类的接受程度，更推荐用日历时间作为分区，对于有25小时的那天，则把存在重复的1小时累计统计。

又咨询了欧美人是怎么处理overlap时间，比如订机票的时候，11月1号的凌晨1:30会有两种表述方式

1. 1:30 AM DST Time（前一个时间）
2. 1:30 AM Standard Time（钟表回调后的时间）

crontab的处理则是11月1号只在第1个1:30 AM触发（即DST Time），后一个1:30（Standard Time）不会被触发。
