# 我对两种同步异步的认识

网络编程中经常会遇到如上四个概念，网上也有很多讲解，我想讲一个
至少是没有看到过的提法。

先给我的认识：

* 同步异步：针对的是函数调用者，即caller而言
* 阻塞非阻塞：针对的是函数实现者，即callee而言

先说阻塞非阻塞，落实到代码就一句话，文件句柄有没有设置过`NONBLOCK`。
一旦设置了`NONBLOCK`，则耗时的网络操作就不会等待，立即返回。
因此函数就不会**阻塞**在网络IO上。由于默认的文件句柄都是BLOCK，
所以对这概念需要一点时间来理解。

同步异步说的是业务层的一种逻辑做法，它的前提就是函数区分了阻塞和非阻塞。
由于函数的实现有了阻塞和非阻塞的区分，一旦调用非阻塞函数，
看起来函数是返回了，但结果却还在网络的另一端，此时有两种做法：

1. 等着消息返回，不停地查询IO结果，等结果出来了流程再继续走下去
2. 先做别的事，等消息返回了再回过头来处理这个非阻塞的消息

1的做法，是同步，而2的做法，则是异步。

从上面可以看出，由于调用阻塞函数只能等待，因此一定是同步调用。
只有非阻塞函数才会出现同步和异步两种情况。虽然理论上非阻塞函数
可以按同步的方法做逻辑，但这样一来就与调用阻塞函数没有区别，
体现不出非阻塞函数的优点，因此实际运用时，
非阻塞函数通常都是按异步模式来处理。

异步模式最明显的风格就是设置回调函数，原因很明显：因为不知道什么时候
非阻塞函数会返回，所以只能把一个callback函数往下设，由下层来回调这个函数。
由于这种写法不符合普通人的逻辑，因此异步的逻辑很不好写。
也有人会将非阻塞函数按同步的逻辑来写，就是常说的异步转同步，
其实我倒觉得更严谨的说法，是同步地调用非阻塞函数，更准确。

另外针对回调函数不直观的做法，业界也有诸如coroutine，promise等方案，
可以做到看上去像同步的写法，但实质上并不会导致CPU空转的做法，
这块还没研究透，就先不铺开了。

再说说同步回调和异步回调

程序中经常会遇到钩子函数和回调，这里就引申出回调函数何时执行的问题。一个函数最终都会在确定的线程中执行，先考虑触发形式的回调，执行触发逻辑的线程，和回调函数执行线程是否在同一个线程，就分为了同步回调和异步回调两种类型。

同步回调方式，比如外部触发一个notify，所有注册的回调函数就会在notify的内部依次执行，所有都执行结束notify才会返回。坏处是notify可能会等待很久，但是逻辑非常清楚，调用者可以很确定地知道注册的回调业务执行完毕，在notify之后可以放心地做其它工作。

与之相对应的是异步回调，这时触发notify可以很快返回，然后另一个线程就会被唤醒，但因为另一个线程什么时候开始执行，更重要的是什么时候结束是完全无法预测的，导致notify之后业务状态不确定，很多的复杂逻辑是无法开展的。

这两种回调，在公司代码中都有体现，其中异步回调是网络框架的Close和`handle_close`，这也是一个初学者经常犯错误的地方，由于Close之后什么时候执行`handle_close`未知，也就不能在Close之后对NetHandler做任何操作，一旦赋值或delete就很容易招来死机。同步回调则是上层的事件中心notify，触发事件后，把所有注册函数执行完才返回，从调用者来看，notify之后，至少业务是完了状态，不过回调函数的成功或失败状态无法返回，不过到底要不要返回，似乎也无必要。

至于定时回调，比较多的是有个独立线程进行异步回调。但也有单线程模式下在同一个线程内回调，如果业务执行得比较久，定时器的精度会比较成问题。